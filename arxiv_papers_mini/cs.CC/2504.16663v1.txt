Online and Feasible Presentability: From Trees to
Modal Algebras∗
Nikolay Bazhenov /envel⌢pe
Novosibirsk State University, Novosibirsk, Russia
Dariusz Kalociński /envel⌢pe
Institute of Computer Science, Polish Academy of Sciences, Warsaw, Poland
Michał Wrocławski /envel⌢pe
Faculty of Philosophy, University of Warsaw, Poland
Abstract
We investigate whether every computable member of a given class of structures admits a fully
primitive recursive (also known as punctual) or fully P-TIME copy. A class with this property is
referred to as punctually robust or P-TIME robust, respectively. We present both positive and
negative results for structures corresponding to well-known representations of trees, such as binary
trees, ordered trees, sequential (or prefix) trees, and partially ordered (poset) trees. A corollary
of one of our results on trees is that semilattices and lattices are not punctually robust. In the
main result of the paper, we demonstrate that, unlike Boolean algebras, modal algebras—–that is,
Boolean algebras with modality—–are not punctually robust. The question of whether distributive
lattices are punctually robust remains open. The paper contributes to a decades-old program on
effective and feasible algebra, which has recently gained momentum due to rapid developments in
punctual structure theory and its connections to online presentations of structures.
2012 ACM Subject Classification Theory of computation →Computability
Keywords and phrases Algebraic structure, computable structure, fully primitive recursive structure,
punctual structure, polynomial-time computable structure, punctual robustness, tree, semilattice,
lattice, Boolean algebra, modal algebra
Funding Nikolay Bazhenov : The work of N. Bazhenov is supported by the Mathematical Center in
Akademgorodok under the agreement No. 075-15-2022-282 with the Ministry of Science and Higher
Education of the Russian Federation.
Dariusz Kalociński : The work of D. Kalociński is supported by the National Science Centre Poland
under the agreement no. 2023/49/B/HS1/03930.
Acknowledgements We would like to thank Luca San Mauro and the reviewers for helpful comments.
1 Introduction
Suppose an infinite graph G= (N,E)is given via a computer program P, which, for any pair
x,y∈N, determines whether E(x,y)holds. This graph is an infinite structure represented
in a finitary manner. Such structures are called computable.1However, without further
restrictions on P, the presentation of GviaPmay be inefficient. Does there always exist a
more efficient representation of G—that is a computer program P′such thatP′computesE′,
G′= (N,E′)is isomorphic to G, andE′is primitive recursive or even P-TIME computable?
The answer to the question posed above is negative [ 28]. However, if we impose certain
structural restrictions on G—–such as requiring Gto be strongly locally finite or to be a
∗This is a related version of the paper accepted at ICALP 2025.
1An infinite countable structure Ais computable if the domain of Ais a computable subset of Nand all
the relations and functions from the signature of Aare uniformly computable [2].arXiv:2504.16663v1  [math.LO]  23 Apr 2025
2 Online and Feasible Presentability: From Trees to Modal Algebras
tree—–the answer becomes positive [ 15]. A more general condition that guarantees the
existence of a nice copy of Ghas been presented in [29].
The question raised in the opening paragraph admits several natural generalizations. For
instance, one could replace graphs with other structures or explore alternative effectiveness
conditions beyond primitive recursiveness or polynomial-time computability. Various in-
stances of this question have drawn interest from researchers at the intersection of automata
theory, complexity theory, and computable algebra. Notable examples include studies on
algebraic structures represented by finite-state automata [ 31,9,23] and investigations into
polynomial-time algebra [ 37,13,1]. Recently, Kalimullin, Melnikov, and Ng [ 28] initiated
a research program at the intersection of computability and complexity, where primitive
recursiveness serves as a fundamental tool for representing structures. Henceforth, we adopt
this paradigm in the paper.
▶Definition 1 (punctual structure [ 28]).An infinite structure over a finite signature is
punctual if its domain is Nand all of its relations and functions are primitive recursive.
In the literature, punctual structures are also referred to as fully primitive recursive (fpr).
The purpose of the above definition was to capture the notion of an infinite structure
which can be presented in an online fashion, or “without delay”. The requirement that the
domain be N(or anyfixedprimitive recursive subset of N) is significant. If, instead, we
require the domain can be anyprimitive recursive subset of N, a distinct notion arises (cf.
Theorem 1.2 in [ 13] and the associated discussion). More importantly, structures satisfying
the relaxed definition may lack the typical online characteristics [28, 5].
Henceforth, all structures, unless stated otherwise, are countably infinite.
A more detailed explanation of the underlying nature of punctual structures follows. This
will be useful later, as many subsequent constructions adhere to this general pattern.
Essentially, a punctual structure Amay be given by a primitive recursive algorithm P
which, on input x=x1,x2,...,xn, determines RA(x)andfA(x), for every R,ffrom the
signature ofA. Intuitively, for arguments xi≤s(wheres∈N), all the relations and function
values are determined by the primitive recursive computation P(x)which should converge by
the computational stage s. In a manner of speaking, our decision whether R(x), or what is
f(x), must be quick, or made without delay . Herequickandwithout delay meansnow, that
is at most at the stage s. In fact, Definition 1 allows for a delay, but the delay itself must be
primitive recursive—any instance of a truly unbounded search is prohibited.
As observed above, a punctual presentation of a structure possesses the following core
property: input is received and processed incrementally, and decisions about incoming data
must be made without access to the complete set of problem data . This property is a defining
characteristic of online procedures in general, both in finite and infinite settings: in the
finite setting, online algorithmics comprises a distinctive subfield of computer science, where
performances of online algorithms are compared, relative to the offline performance, using
competitive analysis (see, e.g., [ 10]); in the infinite setting, online graph coloring procedures
from infinite combinatorics serve as a pertinent example (see, e.g., [ 32]). Due to the core
property punctual structures share with online algorithms, it has been suggested that they
encapsulate, at least partially, what may intuitively be described as a truly online presentation
of a countably infinite structure; the justification of this approach is a delicate task and has
been accomplished elsewhere [28, 5]. For alternative theoretical approaches, see [19, 3].
The theory of online structures has rapidly emerged as an intriguing subfield of computable
structure theory, yielding an impressive amount of results across various topics, including
universality[ 18,21], degreestructures[ 7,24,36], anddefinability[ 27], amongothers[ 6,17,35].
One of the central topics in online structure theory concerns punctual presentability.
N. Bazhenov, D. Kalociński, and M. Wrocławski 3
▶Definition 2. A structure is punctually presentable if it is isomorphic to a punctual one.
This definition formalizes the property we asked about Gin the opening paragraph of this
paper. More generally, given a class Kof structures, we ask whether every computable
member of Khas a punctual copy.
▶Definition 3 (punctual robustness [ 29]).We say that a class of structures Kispunctually
robust, if every computable member of Kis punctually presentable.
Turning to more feasible computations, similar notions naturally arise in the polynomial-
time setting. As usual, our underlying model for P-TIME computations is provided by
Turing machines.
▶Definition 4 (P-TIME structure and P-TIME robustness) .ByBwe denote{0,1}<ω, i.e.,
the set of all finite binary strings. A structure Sin a finite signature LisP-TIME (or
polynomial-time computable) if the domain of Sis a polynomial-time computable subset of B,
and all the L-relations and L-functions ofSare polynomial-time computable. A P-TIME
structureSisfully P-TIME if the domain ofSis equal to B. A structure is fully P-TIME
presentable if it is isomorphic to a fully P-TIME structure.
We say that a class of structures KisP-TIME robust if every computable member of K
is fully P-TIME presentable.
We note that for this framework, in place of the binary alphabet {0,1}in the definition
of P-TIME robustness, one can choose an arbitrary alphabet Σwhich contains at least two
symbols (see, e.g., Chapter 3 in [11]).
A proof of punctual/P-TIME non-robustness for a given isomorphism-closed class Kof
L-structures (where Lindicates the signature) usually requires specific strategies tailored
to the type of structure we are dealing with. However, the general scheme is an example
of diagonalization and can be framed in game-theoretic terms as follows. We imagine
playing a game against infinitely many adversaries A1,A2,.... Adversaries are given via
a computable enumeration. Each Aiis a punctual/P-TIME L-structure andA1,A2,...
contains all isomorphism-types of punctual/P-TIME copies of the structures from K. The
proof must give a computable strategy for building B∈Ksuch that∀i(Ai∈K⇒B̸∼=Ai).
The following classes of structures have been shown to be punctually robust: equivalence
structures [ 13,28], (relational) successor trees [ 15], linear orders [ 25,28], torsion-free abelian
groups [28], Boolean algebras [ 28], abelianp-groups [28], graphs with infinite semitransversals
[29]; on the other hand, there are computable undirected graphs [ 28], computable torsion
abelian groups [ 12], computable Archimedean ordered abelian groups [ 28] and functional
predecessor trees [29] with no punctual copy.
Contributions
InthisworkweprovidenewresultsonpunctualandP-TIMErobustnessoftrees, (semi)lattices
and modal algebras. Note that if a class is not punctually robust then it is not P-TIME
robust either. Hence, P-TIME robustness is attested only for punctually robust classes. In
the following, we briefly describe each of the three contributions.
The first group of results concerns trees. It is a continuation of the work by Cenzer and
Remmel on (variations of) relational successor trees [ 15], as well as of Kalociński, San Mauro
and Wrocławski on functional predecessor trees [ 29]. Our results extend this line of research
to a few other well-known tree structures.
One of the fundamental types of tree-like structures is an ordered tree ([ 33], p. 306). This
concept arises naturally by imposing an ordering on the children of each node in the tree.
4 Online and Feasible Presentability: From Trees to Modal Algebras
To avoid confusion with poset trees (to be defined), we use the term relational predecessor
trees with ordering . The definition could have used the successor relation instead, without
affecting Theorem 6 (see below).
▶Definition 5 (r.p.o. tree) .T= (T,P,<,r )is a relational predecessor tree with ordering
(abbreviated r.p.o. tree) if Pis a binary relation and <is a partial ordering satisfying:
1.(T,P)is a directed graph such that all edges are oriented towards the root r, and the
underlying undirected graph is connected and acyclic,
2.for everyx,y∈T,x≤y∨y≤xiffxandyhave the same parent.
The relation Pis the immediate predecessor relation of the tree. In Section 2 we prove:
▶Theorem 6. The class of r.p.o. trees is punctually robust and P-TIME robust.
Theorem 6 unifies and expands on both the results of Cenzer and Remmel [ 15] on trees,
and of Grigorieff [25] on linear orderings.
Another type of the tree that we consider is a poset tree. Given a partial order (P,≤),
we defineP≤x={y∈P:y≤x}andP≥x={y∈P:y≥x}.
▶Definition 7 (poset tree) .A partial order (P,≤)is a poset tree if (P,≤)has the greatest
element (the root) and, for every x∈P,P≥xis a finite linear order.
Such trees are well-known in set theory, where a tree is a partially ordered set (P,<),
usually with the least element, such that for each x∈P, the setP<xis well-ordered (see,
e.g., Definition 9.10 in [ 26]). The inessential difference between the two definitions is the
direction in which the tree grows. A more important difference is that, in set theory, a node
may be infinitely far apart from the root. Our definition does not allow it. However, the
following theorem of ours, which we prove in Section 3, works even for the class of trees in
the set-theoretic sense (provided we reverse the growth direction):
▶Theorem 8. Poset trees are not punctually robust.
While the underlying combinatorial idea behind the proof is quite intuitive, and some
variants of it have been used elsewhere for a stronger notion of a tree [ 15], the present
case requires much more care, as nodes in a poset tree do not carry information about
their distances from the root. Even more importantly, Theorem 8 yields non-robustness of
structures that lie intermediate between trees and Boolean algebras:
▶Corollary 9. The following classes of structures are not punctually robust:
(i)join semilattices and meet semilattices,
(ii)lattices, complemented lattices, and non-distributive lattices.
The result holds under both order-theoretic and algebraic interpretation.
The remaining open question is whether the class of distributive lattices is punctually
robust. The strategy used to obtain Theorem 8 is closely related to the ‘non-distributivity’
of the computable poset tree we construct, and is therefore unlikely to provide a solution.
To resolve the question, a different approach would be required, if distributive lattices are
punctually robust at all.
The third contribution deals with modal algebras which are obtained from Boolean
algebras by adding a modality operator. Boolean algebras constitute a classical object in
mathematical logic. It is well-known that the class of Boolean algebras provides algebraic
semantics for the classical propositional calculus (see, e.g., [ 38]). On the other hand,
N. Bazhenov, D. Kalociński, and M. Wrocławski 5
countable Boolean algebras are well-studied in computable structure theory—we refer to the
monographs [22, 20] for a detailed exposition of results in this area.
Intuitively speaking, here we treat a modality as a formal logical operator which expresses
the possibility of formulas: ♢pmeans that the statement pis possible. More formally, one
typically considers additional logical connectives ♢(the possibility operator) and □(the
necessity operator), and defines an appropriate modal propositional calculus which extends
the classical propositional calculus (see, e.g., the monograph [ 16]). Modal algebras provide
algebraic semantics for (normal) modal logics. The formal definition of a modal algebra is
given in Section 4. In contrast to Boolean algebras, there are only few known results about
computable presentations of modal algebras—here we cite [30, 4].
It turns out that adding modality ♢to the language of Boolean algebras enriches the
computational content of the class: while (pure) Boolean algebras are punctually robust
(informally, they are computationally ‘tame’) [ 28], modal algebras are not punctually robust
(i.e., some of them can exhibit a ‘wilder’ subrecursive behavior). In Section 4 we prove:
▶Theorem 10. The class of modal algebras is not punctually robust.
Last but not least, we provide some elementary results about robustness of infinite binary
trees (Appendix A) and prefix trees (Appendix B).
2 Relational Predecessor Trees with Ordering
IfP(x,y)holds andx̸=r, then we say that xis achildofy(andyis a parent of x). Notice
that here we assume that the root rdoes not have parents. If xis a child of yandyis a
child ofz, then we say that xis agrandchild ofz. An analogous convention holds for all
representations of trees under consideration in this article.
▶Definition 11. IfTis a tree (r.p.o. tree or a different type) and ais a node of that tree,
then we define the depth of ain the following way: for the root of the tree dT(r) = 0and
wheneverbis a child of a, thendT(b) =dT(a) + 1. In case of representations of trees with an
empty node ewe also define dT(e) =−1. We also defineT≤nto be the part ofTconsisting
only of nodes with a depth less or equal n.
Because of the space limit, here we only prove a specific case of Theorem 6. The full
proof of Theorem 6 appears in Appendix C.
▶Theorem 12. The class of r.p.o. trees of unbounded depth is P-TIME robust.
Proof.We fix a computable T= (B,PT,<T,rT). We carry out the construction in stages
s= 0,1,.... During each stage we perform a fixed number lof steps of some algorithm
calculatingT. We can assume that during each stage the algorithm at most once returns a
true statement of the type either PT(a,b)ora<Tbfor somea,b∈Band that in each such
caseaandbare connected to the root of the current approximation of T.
We are going to construct a P-TIME copy R∼=T. At the end of each stage sstructures
TsandRsare going to be our current approximations of TandRrespectively. We observe
that according to the construction described below both of them will be rooted at every
stage but at some stages they could be not isomorphic to each other. We are also going to
construct an isomorphism φ:T →R.
To ensure that the construction is P-TIME, if for some time we do not discover any new
relations inT, we can delay establishing positive cases of relations in Rby putting new fresh
strings into a reservoir set A. The strings in that set will not be immediately put in a fixed
6 Online and Feasible Presentability: From Trees to Modal Algebras
place in the tree Rbut we will guarantee that none of them can be in either relation with
each other. Thus, while waiting to discover positive cases of relations in T, we will keep
adding negative cases of relations to R. Since the tree has infinite depth, we are guaranteed
to be able to add all the strings from the reservoir to the P-TIME tree at some point.
We order Bin the following way: α⊏βif eitherlh(α)< lh(β)orlh(α) =lh(β)and
additionally on the first position that they differ, αhas0andβhas1.
We construct the reservoir set A. InitiallyA=∅. At the end of each stage swe take the
⊏-least sequence αfrom outsideRs, addαtoAand declare that αis short.
We want to ensure that during infinitely many stages Ts∼=Rs. We only intend to update
Rsto satisfy this condition if we discover a,b,c∈Tsuch thatPT(b,a)andPT(c,b)and
the isomorphism φ(a) =αis defined while φ(b)andφ(c)are not defined. Then we define
φ(c) =βwhereβis the⊏-least element of Aand we remove βfromA.
For every other d∈Ts\φ−1[Rs]:d1,···,dj, we take the ⊏-least sequences of length at
leasts:δ1,···,δjand defineφ(di) =δifor1≤i≤j. We declare that all δiare long.
Verification
▶Lemma 13.Rs∼=Tsinfinitely many times.
Proof.Suppose that the depth of Tsisdsat the end of some stage s,Rsis isomorphic toTs
andRsdoes not change later.
Then the depth of Ttis at mostds+ 1for allt≥s. This is because otherwise Ttwould
have an element aof depthdt>ds+ 1such thata0,···,adtis a path inTtstarting from
the roota0=runtiladt=a. In this path some aiis the last element such that φ(ai) =αi
is defined. Since this path has not been prolonged in Rtbeyondαiwe conclude that i=dt
ori=dt−1. Hence the depth of αiis eitherdtordt−1. Also since αiis inRswe conlude
that the depth of αiis less or equal ds. Hencedt−1≤dswhich is impossible.
Since the depth of Ttis less or equal ds+ 1we obtain a contradiction with the assumption
that this tree is unbounded. ◀
The above lemma implies that T∼=R.
▶Lemma 14. The domain ofRisB.
Proof.We observe that ⊏is a well-ordering on B. We suppose that αis the⊏-least sequence
not in the domain of R.
Thenαwas never added to Abecause every sequence from Ais eventually added to R
(sinceRgets extended infinitely many times and each time the ⊏-least sequence from Ais
used to perform such extension). The sequence αcan only avoid getting added to Aifαis
long and was earlier added to Rbut this is also a contradiction. ◀
▶Lemma 15. PRand<Rare P-TIME.
Proof.We observe that if αandβare in either relation from the signature, then either of
them is long (maybe both of them). We assume that βis long and that lh(α)≤lh(β) =s.
Then to discover that αandβare in a relation we perform the construction until stage s
and check ifRsconfirms that they are. We observe that if αandβdo not enter a relation
at the latest during stage s, then they do not later.
We show that the above procedure is P-TIME. To perform the construction until stage s
we perform l×ssteps of the algorithm calculating Tand we add at most snew sequences
toR, the length of each of them with a rough upper bound of s. Hence the algorithm is
P-TIME. ◀
N. Bazhenov, D. Kalociński, and M. Wrocławski 7
Theorem 12 is proven. ◀
3 Poset Trees
Let(T,≤)be a poset tree. We say that elements x,y∈Tare adjacent, Adj(x,y), if and
only ifx < y∧¬∃z∈T(x < z < y ), where<is the strict partial order induced by
≤. We sayx∈Tis abranching node ofT(orxbranches in T) if it has at least two
children in T. Such anxinduces a unique subtree of T, called a branching and defined as
br(x,T) ={y∈T:Adj(y,x)}∪T≥x. Ifxis a branching node, we define |br(x,T)|, the
length ofbr(x,T), as the length of T≥x. By abinary branching we mean a tree with exactly
two leaves sharing a parent. We say that (T,≤)isuniquely branching if for every n∈N,
there exists at most one branching node x∈Tsuch that|T≥x|=n. We say that a branching
nodex∈Tbelongs to the levelnofTif the setT>xcontains precisely nbranching nodes.
We denote the level nofTbyT[n]and call its members n-level nodes. Keep in mind that
we number levels 0,1,.... Therefore, the first level is level 0. LevelT[n]may be empty but
ifT[n]̸=∅thenT[k]̸=∅, fork < n. Let (T,≤)be a tree such that its level i,i∈N, is
nonempty. We define T[≤i], thei-level subtree of T, as the least subtree of Tcontaining all
nodes at levels≤itogether with their children. Notice that T[≤i]is the sum of the branchings
br(x,T)for allx∈T[j]such thatj≤i. Byr(T)we denote the root of the tree T.
▶Lemma 16. Let(T,≤)be a finite poset tree in which every internal node has exactly two
children and let F⊆Tbe such that, at every level of Texcept the first, at most one node is
inF. Then there exists a leaf y∈Tsuch thatT≥y∩F=∅.
Proof.By assumption, r(T)/∈F. Letx∈Tbe such that T≥x∩F=∅. The node xhas two
children which are at the same level, so one of them, denote it by x′, is outside F. Therefore,
T≥x′∩F=∅. This way we find a leaf ysuch thatT≥y∩F=∅. ◁
LetT,ˆTbe disjoint finite trees and let z∈Tbe a leaf.T′is obtained from Tby attaching ˆT
tozinTifdom(T′) =dom(T)∪(dom(ˆT)−{r(ˆT)})andx,y∈dom(T′)satisfyAdjT′(x,y)
iffAdjT(x,y)∨Adj ˆT(x,y)∨Adj ˆT(x,r(ˆT))∧y=z.
We are ready to start the proof of Theorem 8. We build a computable poset tree
T= (N,≤T)such that for every i∈N:
Pi= (N,ϕ(2)
i)is a poset tree =⇒ T ̸∼=Pi. (Ri)
Here, (ϕ(2)
i)i∈Nis a computable list of all binary primitive recursive functions.
Intuitively, the strategy will work as follows. We wait (in a dovetail fashion) until Pi
shows large enough fragment Pof itself (all nodes of Piup to level i) isomorphic to the
corresponding fragment of Tthat we construct (otherwise, we are done with Piin the
limit). We enumerate fresh elements into Piso that the current Pioutnumbers the current
approximation of T. These fresh elements form subtrees of Piattached to the leaves of
P. We now apply the pigeonhole principle: one of the subtrees must have more elements
than the corresponding subtree in T—we block the growth of that part in Tand makePi
non-isomorphic to T.
Twill be a uniquely branching poset tree with infinitely many levels . Alongside, we
maintain a dynamic set Fof elements ofTwhose role is to block the growth of the tree.
At odd stages the tree grows wherever Fpermits. At even stages, the strategies for Pi
monitor the relationship between TandPiand put or withdraw elements from Fto satisfy
Ri. At any given stage s′we are dealing with an approximation Pi,s′ofPidefined as
8 Online and Feasible Presentability: From Trees to Modal Algebras
lj
xj
binary branching bjTs−1
l1x1
b1l2
x2
b2l3
x3
b3l4
x4
b4ln−1
xn−1
bn−1ln
xn
bn···
Figure 1 ObtainingTs(black and gray) from Ts−1(black) at odd stage sby attaching binary
branchings bj(left) to ljinTs−1, for 1≤j≤n.
follows:Pi,s′= (Ni,s′,≤i,s′), whereNi,s′={0,1,...,s′−1}and for allx,y∈Ni,s′, we have
x≤i,s′y⇔ϕ(2)
i(x,y) = 1.
A nodey∈Tisclosed(at a given stage) if there exists xsuch thaty≤Txandx∈Fat
that stage. A node yisopenifyis not closed.
Construction We proceed in stages. At the end of stage s, we have a finite tree Ts. We set
T=/uniontext
sTs.
At stages= 0, the domain ofT0isT0={0}and0≤T0. NoRiis satisfied at stage 0,
F=∅. At each subsequent stage s>0, we start with a finite tree Ts−1.
Stages= 2t+ 1(expansionary). Letl1,l2,...,lnbe the open leaves of Ts−1. Construct,
for1≤j≤n, a binary branching bjthat branches at xj, with the root ljand other elements
fresh (i.e., the domain of Tis extended by an interval [|Ts|;b), for a least bsufficient to
construct the branchings), such that after attaching bjtoljinTs−1, the length of the
branching in the new tree starting at xjhas lengthH(Ts−1) +j−1. Declare that tree as Ts
(cf. Figure 1). Observe that if Ts−1is uniquely branching, then Tsis also uniquely branching.
Stages= 2t>0(non-expansionary). SetTs=Ts−1. For eachPi,0≤i≤s, apply the
strategy forPi. StructurallyTsandTs−1are the same, but they may differ with respect to
open nodes (that is, Fat stages−1may be different from Fat stages).
Pi-strategy at stage s= 2t.Lets′=max(s,|Ts|+ 1). We consider the approximation
Pi,s′ofPi. Lets′′=max(s−2,|Ts−2|+ 1). Therefore,Pi,s′′is the approximation of Pithat
we considered at the previous non-expansionary stage (if i≤s′′). We say that the strategy
N. Bazhenov, D. Kalociński, and M. Wrocławski 9
(Ts)[≤i+1]
l1l′
1 lnl′
nx1xn
N1N′
1 NnN′
n···(Pi,s′)[≤i+1]
f(l1)f(l′
1)f(ln)f(l′
n)f(x1)f(xn)
M1M′
1MnM′
n···leveli+ 1
Figure 2 Schematic representation of TsandPi,s′from the point of view of the strategy for Pi
at stage s. Solid lines correspond to the tree (Ts)[≤i+1](left) and (Pi,s′)[≤i+1](right). The strategy
forPimonitors the cardinalities of the subtrees, which are represented by dashed triangles.
is ready if:
i≤s−2, that is,Piwas considered at the previous non-expansionary stage (1)
Pi,s′is a poset tree, (2)
Ts[i+ 1]̸=∅andPi,s′[i+ 1]̸=∅, (3)
(Pi,s′)[≤i+1]= (Pi,s′′)[≤i+1],(Ts)[≤i+1]= (Ts−2)[≤i+1],and (4)
(Ts)[≤i+1]∼=(Pi,s′)[≤i+1]. (5)
If the strategy is not ready, withdraw all (i+ 1)-level nodes from F. If the strategy is
ready and some node from level i+ 1is inF, we do nothing.
The remaining case is when the strategy is ready and nodes from level i+ 1are not in
F. The situation is illustrated in Figure 2. Let fbe an isomorphism from (Ts)[≤i+1]to
(Pi,s′)[≤i+1]. Letx1,...,xnbe the (i+ 1)-level nodes of (Ts)[≤i+1]. Eachxjhas two children
which we denote by ljandl′
j. Eachljandl′
jis the root of a subtree of Tswith cardinality
NjandN′
j, respectively. In Pi,s′, we have the corresponding subtrees with roots f(lj),f(l′
j)
and cardinalities Mj,M′
j. Since (Pi,s′)[≤i+1]∼=(Ts)[≤i+1]butPi,s′has more elements than
Ts, the surplus of elements must be placed in the subtrees just described. By the pigeonhole
principle, it follows that there exists j,1≤j≤n, such that Mj+M′
j>Nj+N′
j. Take the
least suchjand putxjintoF.
Verification
By construction, Tis a binary poset tree and that Tis uniquely branching. It is also easy
to see that the domain of TisNand thatx≤Tyis computable: it is sufficient to wait in an
unbounded loop for a stage sat whichx,y∈Tsand respond how they are related in Ts.
▶Lemma 17.Tis infinite. Hence, it has infinitely many levels.
Proof.It is sufficient to prove that at every stage s,Tshas at least one open leaf (and thus,
the tree is extended at each expansionary stage). It is easy to see that T3has levels 0and1(it
looks like two binary branchings attached to the root). Let s≥3. ConsiderT′
sobtained from
Tsas follows: for every branching nodes x,y∈Tssuch thatx<Tyand with no branching
nodes between them, the path {z∈Ts:x <Tz≤Ty}is collapsed to the single element
10 Online and Feasible Presentability: From Trees to Modal Algebras
y(visually speaking, the nodes connecting two branching nodes from adjacent levels are
erased). Observe that T′
sis a finite proper binary tree. By construction, T′
sandFsatisfy
the premise of Lemma 16. Therefore, T′
shas an open leaf. It is immediate that Tshas an
open leaf as well. It is easy to see that Thas infinitely many branching nodes and infinitely
many levels. ◁
▶Lemma 18. Every requirement is eventually satisfied.
Proof.Fix a requirement Riand assumePiis a poset tree. We may additionally assume
thatPiis binary and that Pi[i+ 1]is nonempty (that is, Pihas leveli+ 1). If it does not,
thenRiis satisfied, because Thas infinitely many levels by Lemma 17.
Each of the properties (1),(2),(3)and(4)corresponds to a computable predicate of
two variables, iands. ForPisatisfying the assumptions from the previous paragraph, the
corresponding predicates hold in the limit—there is s0such that they are true when s>s 0:
Property (1).Immediate.
Property (2).Recall that s′=max(s,|Ts|+1). For large enough s,r(Pi)becomes a member
ofPi,s′. Once this happens, Pi,s′is always a poset tree.
Property (3).The leveli+ 1ofTis nonempty by Lemma 17, it is present in Tsfor large
enoughsby construction. Above we assumed that the level i+ 1ofPiis nonempty.
Property (4).For large enough s,T[≤i+1]⊆Tsand(Pi)[≤i+1]⊆Pi,s′.
Lets0be the least stage such that (1)-(4)hold for all stages s≥s0. In particular, it means
that starting from stage s0, we have (Pi,s)[≤i+1]= (Pi)[≤i+1]and(Ts)[≤i+1]= (T)[≤i+1].
If(5)does not hold at stage s0, then it will not hold anymore, and thus Riis satisfied. So
suppose(5)always holds starting from stage s0and letfbe the isomorphism from (Ts0)[≤i+1]
to(Pi,s0)[≤i+1]. Note that this isomorphism is unique because Tis uniquely branching.
Observe that, at stage s0−2, the strategy forPiwas not ready. If it were, then s′
0=s0−2
would be the least stage such that (1),(2),(3)and(4)hold for all even stages s≥s′
0, which
would contradict our choice of s0. Therefore, at stage s0−2all(i+ 1)-level nodes were
withdrawn from F. Hence, at stage s0, the strategy for Piis ready and nodes from level
i+ 1are not inF. It means that we put some xjfrom leveli+ 1ofTintoF. At stages0,
the subtree ofTwith the root xjhas fewer elements than the corresponding subtree of Pi
with rootf(xj). And this property will hold forever because at any subsequent stage, the
strategy is ready and xj∈F, and in that case we do nothing. Therefore, at any subsequent
expansionary stage, the subtree of Twith rootxjdoes not grow. It remains to observe that
if there were an isomorphism gfromTtoPi, it would have to map xjtof(xj), because
TandPiare isomorphic up to level i+ 1andTis uniquely branching so fhas only one
legitimate choice for the value f(xj). ◁
We recall that a partial ordering L= (L,≤)is called a join semilattice, meet semilattice,
or lattice if, for any two elements a,binL, there exists a least upper bound (denoted
a∪b), a greatest lower bound (denoted a∩b), or both, respectively. Join semilattices, meet
semilattices, and lattices are also represented as algebraic structures, namely (L,∪),(L,∩),
and(L,∪,∩), respectively, and are characterized by appropriate axioms. For further details
on lattices, we refer the reader to the standard literature [8].
We reserve the term (semi)lattice to refer specifically to these algebraic structures,
while the term order-theoretic (semi)lattice is used for structures of the form (L,≤). For
(semi)lattices, the order ≤and the operations ∪and∩are mutually definable. Specifically,
x≤yif and only if x∪y=y, andx≤yif and only if x∩y=x.
N. Bazhenov, D. Kalociński, and M. Wrocławski 11
▶Corollary 9. The following classes of structures are not punctually robust:
(i)join semilattices and meet semilattices,
(ii)lattices, complemented lattices, and non-distributive lattices.
The result holds under both order-theoretic and algebraic interpretation.
Proof of Corollary 9 (i).LetT= (N,⊆)be the poset tree from Theorem 8. Since ⊆is a
partial ordering of Nand the join of x,y∈Nis well defined,Tis an order-theoretic join
semilattice and, by Theorem 8, it has no punctual presentation. By defining x⊆∗y⇔y⊆x,
and arguing as above, T∗= (N,⊆∗)is a computable order-theoretic meet semilattice with
no punctual copy.
Letx∪ydenote the join of xandyinT. Consider the join semilattice (N,∪). The join
x∪yis a computable function of x,y: we run the construction from the proof of Theorem 8
and wait for a stage sat which both xandyenterTs. Then we have two cases:
1.For⊆-comparable x,y, we return the maximum of x,ywith respect to⊆.
2.For⊆-incomparable x,y, the construction guarantees that T⊇x∪T⊇y⊂Ts, and thus
x∪ycan be computed from Ts.
It follows that (N,∪)is a computable join semilattice.
To show that (N,∪)is not punctually presentable, assume otherwise. Let (N,∪′)be a
punctual copy of (N,∪), and letx⊆′y⇔x∪′y=y. Hence, the relation x⊆′yis primitive
recursive. But then (N,⊆′)is a punctual copy of Twhich is impossible by Theorem 8.
An analogous proof works for (N,∩∗), the meet semilattice induced by T∗= (N,⊆∗).
◁
Proof of Corollary 9 (ii).LetL−= (N\{0},⊑)beapunctualposettreesatisfyingthefollowing
condition: for all x,y∈N\{0},x⊑y⇔x−1⊆y−1. We observe that T∼=L−via
primitive recursive isomorphism φ:N→N\{0}. The root ofL−is equal to 1.
LetL= (N,⊑)be such thatL−is a submodel of Land0⊑x, for allx∈Nandx̸⊑0,
for allx∈N\{0}. It is easy to see that Lis a computable partial order. Moreover, Lis a
lattice. The join of x,y∈N\{0}inLis the same as in L−. The join of 0,x, wherex∈N,
isx. The meet of x,ysuch thatx⊑yisx. The meet of x,ysuch thatx̸⊑y,y̸⊑xis0. It
is clear that the corresponding algebraic structure (N,⊔,⊓)where⊔,⊓are the join and the
meet functions of L, respectively, is computable.
Observe thatLis a complemented lattice. The integer 1is the greatest element of Land
0is the least. We show that each a∈Lhas a complement, that is, bsuch thata∪b= 1
anda∩b= 0. The construction of Theorem 8 guarantees that 0is a branching node in T,
and thus 1is a branching node in L. Letl,rbe the two children of 1inL.0and1are
complements of each other. Assume that a /∈{0,1}. Eithera⊑lora⊑r. Ifa⊑l,a∪r= 1
anda∩r= 0. Similarly, if a⊑r,a∪l= 1anda∩l= 0.
Next, we prove that (N,⊔,⊓)is not punctually presentable. Towards a contradiction,
letL′= (N,⊔′,⊓′)be a punctual copy of L= (N,⊔,⊓). Let (N,⊑′)be the order-theoretic
counterpart ofL′, i.e.,⊔′and⊓′are the join and meet of L′, respectively. Let 0L′be
the least element of L′. It is clear that (N\{0L′},⊑′)∼=T. Now, given a primitive
recursive bijection f:N→N\{0L′}, we define a punctual structure T′= (N,⊆′)as
follows:x⊆′y⇔f(x)⊑′f(y). The primitive recursiveness of ⊆′follows from the following
equivalences: x⊆′y⇔f(x)⊑′f(y)⇔f(x)∪′f(y) =f(y)and the fact that ∪′is primitive
recursive. Hence T′is a punctual copy of Twhich contradicts Theorem 8. ◁
12 Online and Feasible Presentability: From Trees to Modal Algebras
4 Modal Algebras
In this section, we mainly follow notations from the monographs [ 22,34]. Boolean algebras
are viewed as algebraic structures in the signature {∪,∩,C,0,1}. Informally speaking, one
can think of the signature functions as the usual set-theoretic operations: union, intersection,
and complement. In addition, 0is a least element, and 1is a greatest element.
LetBbe a Boolean algebra. A function f:B→Bis called a modality iffsatisfies the
following two properties:
f(a∪b) =f(a)∪f(b)for alla,b∈B,
f(0B) = 0B.
Informally, one can view f(x)as the result of applying the possibility operator ♢=fto the
‘statement’ x. Iffis a modality, then the structure (B,f)is called a modal algebra . Here we
prove the following result:
▶Theorem 10. The class of modal algebras is not punctually robust.
The proof idea is similar to the one for non-punctual robustness of torsion abelian groups
(Theorem 3.2 in [ 28]). We build a computable modal algebra A∗. Given a punctual ‘adversary’
structurePe(in the signature of modal algebras), we want Peto show an element cewith
some specific properties. Namely, either cegenerates (via the function fPe) an infinite
substructure inside Pe, orceis a part of an fPe-cycle of some finite size Ne. In the first
case, we will win ‘automatically’, since our A∗will not contain elements generating infinite
substructures. In the second case, we try to prevent some fixed prime factor pofNefrom
appearing in the possible sizes of the fA∗-cycles. Preventing such pfrom appearing is quite
a delicate technical task which is achieved via careful ‘algebraic-flavored’ arrangements. In
each of the two cases, we ensure that A∗̸∼=Pe. As usual, an appropriately organized priority
construction allows to successfully deal with a whole computable sequence of adversaries.
We note that the construction for torsion abelian groups (from [ 28]) is a finite injury
construction, while our construction of a modal algebra is injury-free. There are also some
important differences related to the algebraic properties: for example, in the implemented
construction, our Re-strategy has to work with a specifically selected tuple ¯a=a0,a1,...,aM
of witnesses (in place of just one element cethat was used in the proof idea), and this ¯ais
selected based on the Boolean algebra specifics.
Before proceeding to the formal proof of Theorem 10, we give the necessary algebraic
preliminaries. For a Boolean algebra B, its ordering≤Bis defined in a standard way: x≤By
if and only if x∪y=y. An element a∈Bis anatomifais a minimal non-zero element in
B, i.e., 0<Baand there is no bwith 0<Bb<Ba.
ByAtom (B)we denote the set of atoms of B. TheFréchet ideal Fr(B)is the ideal of
Bgenerated by the set Atom (B). Notice that the ideal Fr(B)contains precisely the finite
sums of atoms.
Letabe an element from a Boolean algebra B. We puta0= C(a)anda1=a.
Let¯a=a0,a1,...,anbe a tuple of elements from B, and let ¯ε= (ε0,ε1,...,εn)∈
{0,1}n+1. We define ¯a¯ε=aε0
0∩aε1
1∩···∩aεnn.The following fact is well-known (see, e.g.,
Exercise 6 in §1.2 of [22]):
▶Lemma 19. LetBbe a Boolean algebra, and let ¯a=a0,...,anbe a tuple fromB. Then
the subalgebra grB(¯a)generated by the set {a0,...,an}contains precisely the finite sums of
the elements ¯a¯ε,ε∈{0,1}n+1.
In addition, if ai̸∈{0B,1B}andai̸=ajfori̸=j, then the finite subalgebra grB(¯a)has
at leastn+ 2atoms. (Notice that an atom of the subalgebra grB(¯a)is not necessarily an
atom of the original algebra B.)
N. Bazhenov, D. Kalociński, and M. Wrocławski 13
It is not hard to prove the following ancillary result:
▶Lemma 20. LetBbe an infinite Boolean algebra, and let gbe an arbitrary map from the
setAtom (B)toB. Then the function
F[g](x) =

0B, ifx= 0B,
g(a0)∪g(a1)∪···∪g(an),ifx=a0∪a1∪···∪an, ai∈Atom (B),
1B, ifx̸∈Fr(B),
is a modality. In addition, if the algebra Bis computable, and the sets Atom (B)andFr(B)
are computable, and the function gis computable, then the modality F[g]is also computable.
▶Definition 21 (forward orbit) .Let(B,f)be a modal algebra. For an element a∈B, the
forward orbit ofa(with respect to f) is the set FOrb (a) ={f(n)(a) :n∈N}.
Now we are ready to start the proof of Theorem 10. By B(N)we denote the Boolean
algebra of all finite and cofinite subsets of N. Beforehand, we choose our underlying
computable Boolean algebra Bas follows. The algebra Bis a computable isomorphic copy of
the direct product B(N)×B(N)such that the sets Atom (B)andFr(B)are computable.
In what follows, we identify BwithB(N)×B(N), and we use the following notations:
⊤0= (1B(N),0B(N))and⊤1= (0B(N),1B(N)).
Let{wi:i∈N}be a computable list of all atoms of B(N). We putui= (wi,0B(N))and
vi= (0B(N),wi).
It is clear that{ui,vi:i∈N}is a computable list of all atoms of B. In addition, we have
ui<B⊤0andvi<B⊤1for alli∈N.
By Lemma 20, it is sufficient for us to construct a computable map g:Atom (B)→B.
Then the desired computable modal algebra A∗is defined as
A∗= (B,F[g]). (6)
4.1 Preparations for the Construction of g
Firstly, we describe the basic module of the construction of the map g, we call this module:
Adding a p-cycle to the map g.Given an odd prime number p, we find the least i∈N
such that the value g(ui)is not yet defined. We also choose the least j∈Nsuch that
g(vj)is undefined.
Letk=/floorleftbigp
2/floorrightbig
. For 0≤m < k, we put:g(ui+m) =vj+m,g(vj+m) =ui+m+1, and
g(ui+k) =ui.
We also say that the set {ui+m:m≤k}∪{vj+ℓ:ℓ<k}is ap-cycle.This concludes the
description of the basic module.
We will ensure the following property of our (future) construction:
(#)For each odd prime p, we add at most one p-cycle tog.
Property (#) is enough to prove the following useful lemma about the cardinalities of
forward orbits.
▶Lemma 22. Suppose that the modal algebra A∗from Eq. (6) satisfies Property (#). In
addition, assume that there are infinitely many primes psuch that we have added a p-cycle to
g. Leta∈A∗anda̸= 0B. Then the element asatisfies precisely one of the following three
cases:
14 Online and Feasible Presentability: From Trees to Modal Algebras
1.a̸∈Fr(B)andF[g](a) = 1B.
2.a∈Fr(B)andF[g](a) =a.
3.a∈Fr(B)andcard(FOrb (a)) =q1·q2·...·qnfor somen≥1and some odd primes qi
such thatqi̸=qjfori̸=j. (Note that here a qi-cycle has been added to gat some stage
of the construction.) In addition, if 0≤i<j < card(FOrb (a)), thenF(i)
[g](a)̸=F(j)
[g](a).
Furthermore, if a∈Fr(B),a̸= 0Banda≤B⊤kfor somek∈{0,1}, then the element a
satisfies Case 3.
Proof.Ifa̸∈Fr(B), then Lemma 20 defines F[g](a) = 1B. Thus, assume that a∈Fr(B)
andF[g](a)̸=a.
By Property (#), for each prime pthe algebraA∗contains at most one p-cycle. We
choose all prime numbers q1,q2,...,qnsuch that:
there exists an atom w∈Atom (B)such thatw≤Baandwbelongs to the (unique)
qi-cycle; and
there exists w′∈Atom (B)such thatw′̸≤Baandw′belongs to the qi-cycle.
Notice that (at least one) such prime qiexists. Indeed, if there are no such primes qi, then
the element asatisfies the following condition:
if an atom wbelongs to a q-cycle and w≤Ba, theneveryatom from this q-cycle lies
≤B-belowa.
This condition implies that F[g](a)must be equal to a(which contradicts our assumption).
DefineM=q1·q2·...·qn. Then a straightforward computation shows the following:
F(M)
[g](a) =aand for all i,jwe have: if 0≤i < j < M , thenF(i)
[g](a)̸=F(j)
[g](a). Hence,
card(FOrb (a)) =M. We deduce that every element a̸= 0Bsatisfies one of the three cases
of the lemma.
Now suppose that a∈Fr(B)\{0B}anda≤B⊤0. Then for some i∈N, we have
ui∈Atom (B)andui≤Ba. On the other hand, for all j∈N, we havevj∈Atom (B)and
vj̸≤Ba. By choosing vjfrom theq-cycle of the atom ui, we deduce that amust satisfy Case 3.
(Ifa∈Fr(B)\{0B}anda≤B⊤1, then one can make a similar argument.) Lemma 22 is
proven. ◀
4.2 Requirements and the Construction of g
Observe the following: the modal algebra A∗from Eq. (6) has a punctual copy if and only if
the structure (A∗,⊤0,⊤1)has a punctual copy. Thus, we fix a uniformly computable list
(Pe)e∈Ncontaining all punctual structures in the signature {∪,∩,C,0,1,f}∪{⊤ 0,⊤1}. We
satisfy the following requirements:
Re:The structure (A∗,⊤0,⊤1)is not isomorphic to Pe.
In what follows, we will abuse the notations: we identify the structures A∗and(A∗,⊤0,⊤1).
At a stages, we will have a finite list of active requirements . Each active requirement Re
possesses a corresponding witness ce∈Pe. Active requirements may be (forever) deactivated .
In addition, at a stage swe will have at most one requirement Re0on the alert . The intended
(full) life-cycle of a given requirement Reis as follows:
inactive∝⇕⊣√∫⊔≀→on the alert∝⇕⊣√∫⊔≀→active∝⇕⊣√∫⊔≀→deactivated.
Along the construction, we always do the following background monitoring procedure . At a
stages, for eachPewithe≤s, we consider the finite set Se,s={0Pe,1Pe,⊤0,Pe,⊤1,Pe}∪{x:
x≤Ns}.Assume that at the stage swe have witnessed one of the following conditions:
(a)Some of the elements from the set
Xe,s=/braceleftbig
¯a¯ε: ¯a= (a1,...,an),1≤n≤card(Se,s), ai∈Se,s,¯ε∈{0,1}n/bracerightbig
N. Bazhenov, D. Kalociński, and M. Wrocławski 15
do not satisfy the axioms of Boolean algebras or the axioms of modal algebras. (Notice
that here the set Xe,sis the ‘potential’ Boolean subalgebra grPe(Se,s)generated by the
setSe,sinsidePe.)
(b)⊤0,Pe∪⊤1,Pe̸= 1Peor⊤0,Pe∩⊤1,Pe̸= 0PeorfPe(⊤0,Pe)̸= 1PeorfPe(⊤1,Pe)̸= 1Pe.
(c)There exist k∈{0,1}andx,y∈Se,s\{0Pe,⊤k,Pe}such thatx∪y=⊤k,Pe,x∩y= 0Pe,
and
eitherfPe(x)̸= 1PeandfPe(y)̸= 1Pe, or
fPe(x) = 1PeandfPe(y) =y, or
fPe(x) = 1Peand1Pe∈{f(m)
Pe(y) :m≤s}.
(d)There exist k∈{0,1}andx,y∈Se,ssuch thatx∩y= 0Pe,x≤Pe⊤k,Pe,y≤Pe⊤k,Pe,
andfPe(x) =fPe(y) = 1Pe.
Then we declare the requirement Redeactivated. Indeed, in this case the structure Pe
cannot be isomorphic to (A∗,⊤0,⊤1). To observe this non-isomorphism for Condition (c)
above, we recall the following fact: if x∪y=⊤0,x∩y= 0Bandx,y̸∈{0B,⊤0}, then
precisely one of the elements b∈{x,y}satisfiesb̸∈Fr(B)andF[g](b) = 1B. By Lemma 22,
the remaining element a∈{x,y}satisfiesa∈Fr(B)andF[g](a)̸=a. In addition, we have
1B̸∈FOrb (a).
To observe non-isomorphism for Condition (d), we recall the following: if x≤B⊤0and
F[g](x) = 1B, thenx̸∈Fr(B)and everyy≤B⊤0∩C(x)satisfiesy∈Fr(B)andF[g](y)̸= 1B.
Due to the described monitoring procedure, in the main construction given below, we
may assume (without loss of generality) that every considered structure Pehas the following
properties, for k∈{0,1}:
(P.0)The reduct ofPeto the signature{∪,∩,C,0,1,f}is a punctual modal algebra. In
addition,⊤0,Pe∪⊤1,Pe= 1Pe,⊤0,Pe∩⊤1,Pe= 0Pe, andfPe(⊤0,Pe) =fPe(⊤1,Pe) = 1Pe.
(P.1)Ify≤Pe⊤k,Pe,y̸= 0PeandfPe(y)̸= 1Pe, thenfPe(y)̸=yand1Pe̸∈FOrbPe(y).
(P.2)Ifx1,x2,...,xn≤Pe⊤k,Peandxi∩xj= 0Pefori̸=j, thenat most one element
y∈{x1,x2,...,xn}satisfiesfPe(y) = 1Pe.
Now we are ready to describe the main construction. Let (ps)s≥1be the increasing list of all
odd prime numbers.
Construction. At stage 0, there are no active requirements. We declare that the requirement
R0is on the alert.
Stages>0.Roughly speaking, the main goal of the stage sis to decide whether to add a
ps-cycle to the map g. In addition, our actions will ensure the following property:
(†)Suppose that by the end of the stage s, an active requirement Rehas a witness ce∈Pe.
Thencesatisfies one of the following two conditions:
either the forward orbit FOrbPe(ce)is infinite, or
thesetFOrbPe(ce)isfiniteandthefollowingimplicationholds: if r=card(FOrbPe(ce))
has a form r=q1·q2·...·qn, wheren≥1and2< q1< q2<···< qnare prime
numbers, then some prime q>psmust divide r.
Intuitively speaking, the choice of such form r=q1·q2·...·qnis dictated by Lemma 22. If
the decomposition of rhas any other form, then Lemma 22 ensures that A∗̸∼=Pe.
If the structureA∗does not contain a ps-cycle by the end of the stage s, then we say
that the prime psisforbidden from entering the structure A∗.
Our actions at the stage sgo as follows. If there is a requirement Re0which is currently
on the alert, then firstly we execute the following strategy.
16 Online and Feasible Presentability: From Trees to Modal Algebras
4.2.1 Strategy for ReWhich Is on the Alert
LetDsbe the Boolean subalgebra of Bgenerated by the following elements: ⊤0,⊤1, and the
elements of all q-cycles added to gat stagest<s. By Lemma 19, the algebra Dsis finite,
and one can computably recover this structure Ds. In addition, Lemma 20 ensures that the
valuesF[g](x)are defined for all x∈Ds.
DefineM=card(Ds). Consider the≤N-least elements b0<Nb1<N···<NbM−1from the
structurePesuch thatbi̸∈{0Pe,1Pe,⊤0,Pe,⊤1,Pe}. We define the following finite Boolean
subalgebra ofPe:Qs=grPe({⊤0,Pe,⊤1,Pe,b0,b1,...,bM−1}).
By Lemma 19, the algebra Qshas at least M+ 3atoms. Applying Property (P.2) of the
construction, we deduce that at most two of these atoms xsatisfyfPe(x) = 1Pe(indeed,
at most one atom below ⊤0,Pe, and at most one atom below ⊤1,Pe). Therefore, among the
atoms ofQswe can find (M+ 1)-many pairwise distinct elements a0,a1,...,aMsuch that
fPe(ai)̸= 1Pe,ai̸= 0Pe, andai∩aj= 0Pefori̸=j.
By Property (P.1), we obtain that fPe(ai)̸=aiand1Pe̸∈FOrbPe(ai). We define
L=/producttexts
j=1pj.We compute the values f(j)
Pe(ai),fori≤Mandj≤L.Then one of the
following five cases is satisfied:
Case(i.a). Thereexists aisuchthatthefunction fPeisnotinjectiveontheset {f(j)
Pe(ai) :j≤
L}(i.e., there exist j1<j2≤Lsuch thatf(j1)
Pe(ai)̸=f(j2)
Pe(ai)andf(j1+1)
Pe(ai) =f(j2+1)
Pe(ai)).
Thenwe (safely)declare therequirement Redeactivated. Indeed, by item (3)of Lemma22,
the structurePecannot be isomorphic to our structure A∗. In all cases (i. X) below, we will
assume that the function fPeis injective on the set {f(j)
Pe(ai) :j≤L}.
Case (i.b). There exists aiwith the following properties:
FOrb (ai)⊆{f(j)
Pe(ai) :j≤L}andN= card(FOrb (ai)).
Consider the prime decomposition N=qα1
1·qα2
2·...·qαℓ
ℓ, whereqj̸=qkforj̸=kand
αj≥1. For some j≤ℓ, eitherqjhas already been forbidden from entering A∗, orqj= 2,
orαj≥2.
Then by Lemma 22, our structure A∗cannot be isomorphic to Pe, sinceA∗does not contain
elementsb∈Fr(B)with card(FOrb (b)) =N. We declare the requirement Redeactivated.
Case (i.c). Neither of Cases (i.a) and (i.b) is satisfied, and there exists aiwith the following
properties:
FOrb (ai)⊆{f(j)
Pe(ai) :j≤L}andN= card(FOrb (ai)).
For somet≥s, the prime ptdividesN.
We declare the requirement Reactive, and we set ce=ai. Note the following: if t>s, then
Rewill definitely satisfy Property ( †) at the end of stage s.
Case (i.d). Neither of Cases (i.a)–(i.c) is satisfied, and there exists aisuch that for all
j < k≤L, we havef(j)
Pe(ai)̸=f(k)
Pe(ai). Notice that this condition is equivalent to the
condition card(FOrb (ai))≥L+ 1. We declare the requirement Reactive, and we define
ce=ai.
Case (i.e). Suppose that neither of Cases (i.a)–(i.d) is satisfied. Then everyai,i≤M, has
the following properties:
(e.1)FOrb (ai)⊆{f(j)
Pe(ai) :j≤L}andNi= card(FOrb (ai))≤L.
N. Bazhenov, D. Kalociński, and M. Wrocławski 17
(e.2)The number Nihas prime decomposition Ni=qi,1·...·qi,ℓi, whereqi,j̸=qi,kfor
j̸=k, and 3≤qi,j<psandqi,jhas not been forbidden from entering A∗.
We show that in this case the structure Peis not isomorphic to A∗. In order to prove this, it
is enough to establish the following fact:
▷Claim 23.A∗does not contain (M+ 1)-many pairwise disjoint elements asatisfying:
card(FOrb (a)) =Nifor someNiwith Property (e.2). (7)
Proof.Suppose that an element a∈A∗satisfies Eq. (7). Consider the prime number qi,1.
By the proof of Lemma 22, there exists an atom a′∈Atom (B)such thata′≤Baanda′
belongs to a qi,1-cycle. By the definition of the finite algebra Ds, we havea′∈Ds. We define
θ(a) =a′. We notice the following fact: if a∩b= 0B, thenθ(a)̸=θ(b). Indeed, if θ(a) =θ(b),
then 0B̸=θ(a)≤Ba∩b.
Now, towards a contradiction, assume that A∗contains (M+ 1)-many pairwise disjoint
elementsasatisfying Eq. (7). Then the algebra Dscontains at least (M+ 1)-many pairwise
distinct elements θ(a). This contradicts the choice of M= card(Ds). ◁
Indeed, recall that ai∩aj= 0Pefori̸=j. Hence, the structure Pedoes contain (M+ 1)-
many disjoint elements a0,...,aMsatisfying Eq. (7). Thus, Claim 23 implies that Pe̸∼=A∗.
Therefore, in Case (i.e), we safely declare the requirement Redeactivated.
This concludes the description of the strategy for Re=Re0which is on the alert. After
executing this strategy, one-by-one, we execute strategies for the currently active requirements
Re′(see below). Notice that in Cases (i.c) and (i.d) above, this execution also includes our
requirement Re0(Re0had been on the alert, but then it moved to becoming active).
4.2.2 Strategy for an Active Requirement Re
As usual, here we assume the following: if the requirement Rewas active at the end of the
previous stage s−1, then it satisfied Property ( †) at that moment. Consider the witness ce
forRe. Recall that
L=s/productdisplay
j=1pj. (8)
We compute the values f(i)
Pe(ce), for alli≤L. One of the following two cases is satisfied:
Case (ii.a). Suppose that f(j)
Pe(ce) =f(k)
Pe(ce)for somej < k≤L. Then we have
FOrbPe(ce)⊆ {f(i)
Pe(ce) :i≤L}. In particular, the set FOrbPe(ce)is finite. For
N= card(FOrbPe(ce)), we compute its prime decomposition N=qα1
1·qα2
2·...·qαℓ
ℓ.
Similarly to Case (i.b), if for some i≤ℓeitherqiwas already forbidden, or qi= 2, or
αi≥2, thenPe̸∼=A∗. Thus, we declare such Redeactivated. Hence, in what follows we
may assume that N=q1·q2·...·qℓ,where 2<q1<q2<···<qℓ.
If someqiequalsps, then we forbidadding aps-cycle to the map g. SinceA∗will not
haveps-cycles, by Lemma 22, we deduce that Peis not isomorphic to A∗. We safely declare
the requirement Redeactivated.
Ifps̸∈{qi:i≤ℓ}, thenRestays active. Here we claim that some qimust be equal
toptfor somet>s. Indeed, if Rewas already active at the stage s−1, then this fact is
guaranteed by the ‘ (s−1)-version’ of Property ( †). Otherwise, Removed from being on the
alert to being active at the stage s. But then this move was triggered by Case (i.c), and
someptwitht>smust divide N. We observe that in Case (ii.a), the requirement Rewill
satisfy Property ( †) at the end of the stage s.
18 Online and Feasible Presentability: From Trees to Modal Algebras
Case (ii.b). Otherwise, f(j)
Pe(ce)̸=f(k)
Pe(ce)for allj < k≤L. Then the requirement Re
stays active. Observe that here N= card(FOrbPe(ce))≥L+ 1.
In Case (ii.b) we need to show that the requirement Rewill still satisfy Property ( †)
by the end of the stage s. Towards a contradiction, assume that Property ( †) fails. Then
the setFOrbPe(ce)is finite, and we have N=q1·q2·...·qℓ, where the primes qisatisfy
2< q1< q2<···< qℓ≤ps. By Eq. (8), we obtain that N=qℓ·qℓ−1·...·q2·q1≤
ps·ps−1·...·ps−(ℓ−2)·ps−(ℓ−1)≤L.This contradicts the fact that N >L.
We deduce that in each of the two cases, an active requirement Rewill satisfy Property ( †)
by the end of the stage s. This concludes the description of the strategy for an active Re.
If by the end of the stage s, no strategy has forbidden to add a ps-cycle tog, then we
proceed as follows:
Add aps-cycle to the map g.
Find the least isuch that the requirement Rihas never been on the alert before. Declare
thisRibeing on the alert.
4.3 Verification
▶Lemma 24. For everya∈Atom (B), the value g(a)is eventually defined. Consequently,
the structureA∗from Eq. (6) is a well-defined computable modal algebra.
Proof.It is sufficient to show that our construction adds a ps-cycle for infinitely many s≥1.
Towards a contradiction, assume that for every s>s 0, the structureA∗never gets a ps-cycle.
Then for every s>s 0, the requirement Rsis never declared on the alert. Consequently, such
Rsnever becomes active.
Choose a large enough stage s∗>s0with the following property: if a requirement Re,
wheree≤s0, is eventually declared deactivated, then Rewas deactivated beforethe stage
s∗. Since the ps∗-cycle is forever forbidden, this forbiddance was triggered by the following
action: at the stage s∗, some currently active requirement Ri, wherei≤s0, forbadeps∗,
and after that this Riwas deactivated. But this contradicts the choice of the stage s∗. We
deduce that g(a)is defined for all atoms afromB. Lemma 24 is proved. ◀
▶Lemma 25. Every requirement Reis satisfied.
Proof.Sinceourconstructionaddsa ps-cycleforinfinitelymany s(asdiscussedinLemma24),
every requirement Reis eventually declared being on the alert. If a requirement Reis
eventually deactivated, then (as discussed in detail in the construction description) we have
Pe̸∼=A∗andReis satisfied.
Suppose that a requirement Reis never deactivated. Then there exists a stage s0such
thatReis active at every stage s≥s0. Consider the corresponding witness ce∈Pe. If
the forward orbit FOrbPe(ce)is infinite, then by Lemma 22, Peis not isomorphic to A∗.
Therefore, we may assume that the set FOrbPe(ce)is finite.
SinceN=card(FOrbPe(ce))<ω, there exists a large enough stage s∗≥s0such that for
everys≥s∗, the active requirement Resatisfies Case (ii.a) at the stage s. The requirement
Reis never deactivated, hence, we have N=q1·q2·...·qℓfor someℓ≥1and some primes
2< q1< q2<···< qℓ. But then Property ( †) of the construction implies that for every
s≥s∗, there exists a prime q > pssuch thatqdividesN. Hence,Nhas infinitely many
divisors, which gives a contradiction. We conclude that for every e, the structureA∗is not
isomorphic toPe. ◀
N. Bazhenov, D. Kalociński, and M. Wrocławski 19
References
1Pavel E. Alaev and Victor L. Selivanov. Polynomial computability of fields of algebraic
numbers. Doklady Mathematics , 98(1):341–343, 2018. doi:10.1134/S1064562418050137 .
2Chris J. Ash and Julia Knight. Computable structures and the hyperarithmetical hierarchy .
Elsevier, 2000.
3Matthew Askes and Rod Downey. Online, computable and punctual structure theory. Logic
Journal of the IGPL , 31(6):1251–1293, August 2022. doi:10.1093/jigpal/jzac065 .
4Nikolay Bazhenov. Categoricity spectra for polymodal algebras. Studia Logica , 104(6):1083–
1097, 2016. doi:10.1007/S11225-016-9667-Y .
5Nikolay Bazhenov, Rod Downey, Iskander Kalimullin, and Alexander Melnikov. Foundations
of online structure theory. Bulletin of Symbolic Logic , 25(2):141–181, 2019. doi:10.1017/bsl.
2019.20.
6Nikolay Bazhenov, Marta Fiori-Carones, Lu Liu, and Alexander G. Melnikov. Primitive
recursive reverse mathematics. Annals of Pure and Applied Logic , 175(1):103354, 2024.
doi:10.1016/J.APAL.2023.103354 .
7Nikolay Bazhenov, Iskander Kalimullin, Alexander Melnikov, and Keng Meng Ng. Online
presentations of finitely generated structures. Theoretical Computer Science , 844:195–216,
2020. doi:10.1016/j.tcs.2020.08.021 .
8Garrett Birkhoff. Lattice Theory , volume 25 of Colloquium Publications . American Mathemat-
ical Society, Providence, Rhode Island, 1940.
9Achim Blumensath and Erich Grädel. Automatic structures. In 15th Annual IEEE Symposium
on Logic in Computer Science, Santa Barbara, California, USA, June 26-29, 2000 , pages
51–62. IEEE Computer Society, 2000. doi:10.1109/LICS.2000.855755 .
10A. Borodin and R. El-Yaniv. Online Computation and Competitive Analysis . Cambridge
University Press, 2005.
11D. Cenzer and J. B. Remmel. Complexity theoretic model theory and algebra. In Handbook
of recursive mathematics, Vol. 1 , volume 138 of Studies in Logic and the Foundations of
Mathematics , pages381–513.North-Holland, Amsterdam, 1998. doi:10.1016/S0049-237X(98)
80011-6.
12Douglas Cenzer and Jeffrey Remmel. Polynomial-time abelian groups. Annals of Pure
and Applied Logic , 56(1):313–363, 1992. URL: https://www.sciencedirect.com/science/
article/pii/016800729290076C ,doi:10.1016/0168-0072(92)90076-C .
13Douglas Cenzer and Jeffrey B. Remmel. Polynomial-time versus recursive models. Annals of
Pure and Applied Logic , 54(1):17–58, 1991.
14Douglas Cenzer and Jeffrey B. Remmel. Feasibly categorical models. In Daniel Leivant, editor,
Logic and Computational Complexity , pages 300–312, Berlin, Heidelberg, 1995. Springer Berlin
Heidelberg.
15Douglas Cenzer and Jeffrey B. Remmel. Feasible graphs with standard universe. Annals of
Pure and Applied Logic , 94(1):21–35, 1998. doi:10.1016/S0168-0072(97)00064-X .
16Alexander Chagrov and Michael Zakharyaschev. Modal Logic . Oxford University Press, Oxford,
1997.
17Marina Dorzhieva and Alexander G. Melnikov. Punctually presented structures I: closure
theorems. Computability , 12(4):323–337, 2023. doi:10.3233/COM-230448 .
18Rod Downey, Noam Greenberg, Alexander Melnikov, Keng Meng Ng, and Daniel Turetsky.
Punctual categoricity and universality. The Journal of Symbolic Logic , 85(4):1427–1466, 2020.
doi:10.1017/jsl.2020.51 .
19Rod Downey, Alexander Melnikov, and Keng Meng Ng. Foundations of Online Structure
Theory II: The Operator Approach. Logical Methods in Computer Science , 17(3):6:1–6:35,
July 2021. URL: https://lmcs.episciences.org/6641 ,doi:10.46298/lmcs-17(3:6)2021 .
20Rodney Downey and Alexander Melnikov. Computable structure theory: A unified approach .
Springer, to appear. URL: https://homepages.ecs.vuw.ac.nz/~melnikal/maindoc.pdf .
20 Online and Feasible Presentability: From Trees to Modal Algebras
21Rodney G. Downey, Matthew Harrison-Trainor, Iskander Sh. Kalimullin, Alexander G. Mel-
nikov, and Daniel Turetsky. Graphs are not universal for online computability. Journal of
Computer and System Sciences , 112:1–12, 2020. doi:10.1016/J.JCSS.2020.02.004 .
22Sergei S. Goncharov. Countable Boolean Algebras and Decidability . Consultants Bureau, New
York, 1997.
23Erich Grädel. Automatic structures: Twenty years later. In Holger Hermanns, Lijun Zhang,
Naoki Kobayashi, and Dale Miller, editors, LICS ’20: 35th Annual ACM/IEEE Symposium on
Logic in Computer Science, Saarbrücken, Germany, July 8-11, 2020 , pages 21–34. ACM, 2020.
doi:10.1145/3373718.3394734 .
24Noam Greenberg, Matthew Harrison-Trainor, Alexander Melnikov, and Dan Turetsky. Non-
density in punctual computability. Annals of Pure and Applied Logic , 172(9):102985, 2021.
doi:10.1016/j.apal.2021.102985 .
25Serge Grigorieff. Every recursive linear ordering has a copy in DTIME-SPACE (n, log (n)).
Journal of Symbolic Logic , 55(1):260–276, 1990. doi:10.2307/2274966 .
26Thomas Jech. Set Theory: The Third Millennium Edition, revised and expanded . Springer
Monographs in Mathematics. Springer Berlin Heidelberg, 2007.
27Iskander Sh. Kalimullin, Alexander G. Melnikov, and Antonio Montalbán. Punctual definability
on structures. Annals of Pure and Applied Logic , 172(8):102987, 2021. doi:10.1016/J.APAL.
2021.102987 .
28Iskander Sh. Kalimullin, Alexander G. Melnikov, and Keng Meng Ng. Algebraic structures
computable without delay. Theoretical Computer Science , 674:73–98, 2017. doi:10.1016/J.
TCS.2017.01.029 .
29Dariusz Kalociński, Luca San Mauro, and Michał Wrocławski. Punctual Presentability in
Certain Classes of Algebraic Structures. In Rastislav Královič and Antonín Kučera, editors,
49th International Symposium on Mathematical Foundations of Computer Science (MFCS
2024), volume 306 of Leibniz International Proceedings in Informatics (LIPIcs) , pages 65:1–
65:15, Dagstuhl, Germany, 2024. Schloss Dagstuhl – Leibniz-Zentrum für Informatik. ISSN:
1868-8969. URL: https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.MFCS.
2024.65,doi:10.4230/LIPIcs.MFCS.2024.65 .
30Bakhadyr Khoussainov and Tomasz Kowalski. Computable isomorphisms of Boolean algebras
with operators. Studia Logica , 100(3):481–496, 2012. doi:10.1007/S11225-012-9411-1 .
31Bakhadyr Khoussainov and Anil Nerode. Automatic presentations of structures. In Daniel
Leivant, editor, Logic and Computational Complexity , volume 960 of Lecture Notes in Computer
Science, pages 367–392. Springer Berlin Heidelberg, 1995. doi:10.1007/3-540-60178-3_93 .
32H. A. Kierstead. Recursive and on-line graph coloring. In Yu L. Ershov, S. S. Goncharov,
A. Nerode, J. B. Remmel, and V. W. Marek, editors, Handbook of Recursive Mathematics,
Vol. 2, volume 139 of Studies in Logic and the Foundations of Mathematics , pages 1233–1269.
Elsevier, 1998. ISSN: 0049-237X. URL: https://www.sciencedirect.com/science/article/
pii/S0049237X98800517 ,doi:10.1016/S0049-237X(98)80051-7 .
33Donald E. Knuth. The Art of Computer Programming. Volume I. Fundamental Algorithms .
The Art of Computer Programming. Addison-Wesley, Reading, Massachusetts, 1968.
34Sabine Koppelberg. Handbook of Boolean Algebras, Volume 1 . North-Holland, Amsterdam,
1989.
35Alexander Melnikov and Keng Meng Ng. A structure of punctual dimension two. Proceedings
of the American Mathematical Society , 148(7):3113–3128, 2020. doi:10.1090/proc/15020 .
36Alexander G. Melnikov and Keng Meng Ng. The back-and-forth method and computab-
ility without delay. Israel Journal of Mathematics , 234(2):959–1000, 2019. doi:10.1007/
s11856-019-1948-5 .
37Anil Nerode and Jeffrey B. Remmel. Complexity-theoretic algebra II: Boolean algebras. Annals
of Pure and Applied Logic , 44(1–2):71–99, 1989. doi:10.1016/0168-0072(89)90047-X .
38Helena Rasiowa and Roman Sikorski. The Mathematics of Metamathematics . Państwowe
Wydawnictwo Naukowe, Warsaw, 1963.
N. Bazhenov, D. Kalociński, and M. Wrocławski 21
A Binary successor trees
A binary tree is a fundamental concept in computer science. Its defining properties are as
follows: there is a distinguished node r, called the root, and each node has at most two
children, referred to as the leftandrightchild. We adopt a representation that provides
left and right successor functions, S1andS2, which map each node to its left or right
child, respectively, or to the “empty node” ewhich indicates the absence of a value. This
representation resembles a common memory model for binary trees (see, e.g., [ 33], p. 316).
▶Definition 26 (binary successor tree) .T= (T,S1,S2,e,r)is a binary successor tree iff S1
andS2are both unary functions satisfying:
1.S1andS2do not have any cycles and are injective on N\(Si)−1(e),
2.ran(S1)∩ran(S2) ={e},
3.ran(S1)∪ran(S2) =N\{r},
4.S1(e) =S2(e) =e.
We observe that punctual presentability of a tree does not depend on including both
constantseandrin the signature. Hence any results of this sort remain valid even if either
constant or both of them are removed from the signature.
▶Definition 27. We say that a successor tree is n-full if every node of depth n−1has both
non-empty successors.
▶Theorem 28. The class of successor trees is not punctually robust.
Proof.We fix an enumeration of all punctual structures over the same signature as successor
treesTn= (N,S1
n,S2
n,en,rn)and we want to construct a tree Tsatisfying all requirements:
(Rs)T ̸∼=Ts.
The construction will be carried out in infinitely many stages, at each stage sthe requirement
Rsis going to be satisfied. At stage 0define the empty node to be number 0and the root to
be number 1.
At the beginning of stage s>0all requirementsR0,...,Rs−1have already been satisfied
andT≤s−1has already been constructed. We calculate all of T≤s
s. There are several
possibilities.
IfT≤s
sis not a successor tree, then the requirement is already satisfied and we can move
on to the next stage. Similarly if T≤s−1̸∼=T≤s−1
s. Now we need to consider the case when
both these trees are isomorphic. We want to ensure that they will somehow be distinguished
by nodes of depth s. We assume that both of them have nnodes of depth s−1:a1,...,an.
IfT≤s
sis nots-full, then we take 2nleast fresh natural numbers b1,...,b 2n, add them to
the domain ofTand we extend functions S1andS2, definingS1(ai) =biandS2(ai) =bi+n,
1≤i≤n.
IfT≤s
siss-full, then we take 2n−1least unused natural numbers b1,...,b 2n−1, add them
to the domain of Tand we extend functions S1andS2, definingS1(ai) =bi(if1≤i≤n),
S2(ai) =bi+n(when 1≤i≤n−1) andS2(an) = 0(we recall that 0represents an empty
node). Thus we ensured that T≤siss-full iffT≤s
sis nots-full. Hence these trees are not
isomorphic andRsis satisfied.
We observe that whenever Thasnnodes of a certain depth s, then there are either 2nor
2n−1nodes of depth s+ 1. Hence the construction never runs out of nodes to prolong. ◀
22 Online and Feasible Presentability: From Trees to Modal Algebras
B Prefix trees
A prefix tree is a familiar object in computability theory and in descriptive set theory. In
general,Tis a prefix tree over a set XifTis a subset of X<ω, the set of all finite sequences
of elements of X, and satisfies the following condition: for every ⃗ a,⃗b∈X<ω, if⃗ a∈Tand⃗b
is a prefix of ⃗ a, then⃗b∈T.
The concept of a prefix tree, as defined above, is not formulated in model-theoretic
terms, which we require for assessing punctual robustness. Therefore, we need a precise
specification of a domain and a signature, along with defining characteristics that determine
which corresponding models qualify as ‘prefix trees.’
Below, we adopt a definition that appears most natural. However, this definition involves
an infinite signature. Unfortunately, the assumed definition of a punctual structure (see
Definition 1) does not specify how to handle cases where the signature is infinite. Thus, we
must take a step back.
So far, no generally accepted definition of a punctual structure with an infinite signature
exists. Various approaches can be taken to introduce such a notion (for a corresponding
framework in polynomial-time algebra, see, e.g., [ 14]). Here, we adopt a particularly strong
definition—likely the strongest among all plausible variants.
▶Definition 29. A structureA= (A,(RA
i)i∈I,(fA
j)j∈J,(cA
k)k∈K)is punctual if Ais equal to
Nor to a finite initial segment of N, all relations, functions, and constants from the signature
are uniformly primitive recursive, and the function assigning to the index of a relation or of
a function the arity is primitive recursive.
Other variants of the above definition could weaken in various ways the requirement that
the arity function is primitive recursive, asking only that this function is recursive or that
for any fixed number we can decide in a primitive recursive way if a certain fixed function or
relation has that many arguments.
▶Definition 30.T= (T,RT
1,RT
2,RT
3,...;rT)is a prefix tree if each RT
nis ann-ary relation,
rT∈Tand the following are satisfied:
1.RT
1={rT},
2.ifRT
n(a1,...,an)and1≤i≤n, thenRT
i(a1,...,ai).
We say that a prefix tree is injective if whenever ⃗ a= (a1,...,an,c)and⃗b= (b1,...,bk,c)
andRT
n+1(⃗ a)andRT
k+1(⃗b), thenn=kanda1=b1,...,an=bn.
The interpretation of the above definition is such that RT
nis the set of all paths of length
nin the prefix tree Twhich start at the root rT. This is in line with a common practice of
defining trees to be sets of strings containing all prefixes of every string included. We slightly
deviate from that convention in that we do not include the empty string.
▶Definition 31. If⃗ a= (a1,...,an),⃗b= (b1,...,bk),k<nandai=biwhenever 1≤i≤k,
then we say that ⃗ aextends⃗bbyn−k.
▶Theorem 32. The class of injective prefix trees is punctually robust.
Proof.We fix a computable injective prefix tree T. We are going to construct a punctual
R∼=T. We assume that Thas an infinite branch. Otherwise the tree has an infinitely
branching node and the proof is standard. The general idea is that we enumerate the children
of that node while waiting to copy the rest of the tree. Also please check the proof of
Proposition 3 in [29].
N. Bazhenov, D. Kalociński, and M. Wrocławski 23
The construction will be carried out in infinitely many stages and at the end of each stage
swe will have determined whether any fixed s-bounded (a1,...,an)∈RT
n. Here we say
that (a1,...,an)iss-bounded if a1,...,an≤s. At the end of stage s−1we have already
recovered someTs−1(a fragment ofT)and constructedRs−1—the image ofTs−1under the
isomorphism φ.
Duringtheentireconstructionwerunanalgorithmcalculating Tandbuildanisomorphism
φ:T →R. We are also going to build W—a set of all paths in Twhich have already been
discovered but are still waiting to get implemented into R. InitiallyW=∅.
At stageswe check if we obtained any new information about T. If not, then we declare
that alls-bounded (a1,...,an)do not belong to RR
nunless we already declared earlier that
they do.
Now we assume that at stage swe discovered that some ⃗ a= (a1,...,an)∈RT
nand that
⃗b= (b1,...,bm)is the longest branch in Ts−1extended by ⃗ a. Ifn<m + 2, then we add the
path (a1,...,an)toW.
Ifn≥m+ 2, then we extendRwith all the paths in Wand then we declare that W:=∅.
Below we describe in more detail how this is done.
WheneverWcontains a path ⃗ a= (a1,...,an)and⃗b= (b1,...,bk)∈RT
kis the longest
branch already copied to Rextended by ⃗ a, then we take t:=n−k−1least unused numbers
c1,...,ctand the least unused number ct+1≥sand we define φ(ai+k) =ci,1≤i≤tand
φ(an) =ct+1. We observe that ⃗C=φ(⃗ a)contains an element ct+1≥sand hence has not
been banned from entering RR
nat any earlier stage. We also observe that since Tcontains
an infinite path, there will always be a stage when some already existing branch is extended
by at least two, and hence every path from Wwill at some point be incorporated into R.◀
▶Theorem 33. The class of prefix trees is not punctually robust.
Proof.First we define an auxiliary notion of a binary prefix tree. The definition is the same
as in the case of prefix trees on an infinite set Twith the only difference being that the
domain is the set A={0,1}.
We observe that any binary prefix tree is punctually presentable if and only if that tree is
already punctual and hence that not all of them are punctually presentable.
We fix a non-punctually presentable binary prefix tree Tb= (A,RTb
1,RTb
2,...,rTb). We
assume that the root rTbis1. We defineT= (N,RT
1,RT
2,...,rT)in the following way. For
eachi≥1,RT
i=RTb
i∪{(1,2,...,i )}andrT= 1. We observe that if Thad a punctual
presentation, then so would Tb. ◀
The definition below works with both finite and infinite signatures and is very similar to
that in the punctual case.
▶Definition 34. A structureA= (B,(RA
i)i∈I,(fA
j)j∈J,(cA
k)k∈K)(where each of the sets
I,J,Kis either the set of all positive natural numbers or a finite initial segment thereof)
is fully P-TIME if all relations, functions, and constants from the signature are uniformly
P-TIME and the function assigning to the index of a relation or a function the arity is
P-TIME.
We understand the above definition in the following way. Initially we have a finite
sequence of elements of the alphabet {0,1,a,b,c,d}on the tape. The input begins with
a sequence of letters a,borc, where the number of occurrences of the letter symbolises
the index of, respectively, a relation, a function or a constant under consideration. This is
followed by the list of arguments of a relation or a function or the element of the domain to
be represented by the constant. When dealing with non-unary relations or functions, the
24 Online and Feasible Presentability: From Trees to Modal Algebras
arguments are separated with the letter d. Hence, if we want to check if (001,010)∈RA
3, we
are going to work on the sequence aaa001d010as the input.
We require that there is a polynomial function Psuch that for any input (defined as
above) of length n, the algorithm halts in at most P(n)steps. This is a very strong definition,
and some weaker variants are possible. A natural weakening of the definition would be to
have individual polynomial bounds on different relations and functions from the signature
(preferably retrievable in a primitive recursive way). A variant of a definition was considered
in [14].
▶Theorem 35. The class of injective prefix trees of unbounded depth is P-TIME robust.
Proof.We only sketch the proof. The general idea of the construction is very similar to that
of Theorem 32. To ensure that the construction works in polynomial time we introduce and
use the distinction between short and long sequences from the proof of Theorem 12.
We copy a fixed tree Tinto some P-TIME tree Rwhile also constructing an isomorphism
φbetween them. Whenever some path in Thad already been copied to R, the current leaf in
the tree under construction is αsuch thatφ(a) =αfor somea∈Tand we have discovered
bandcsuch thatbis the child of aandcis the child of b, then we prolong the isomorphism.
We setφ(b)to be the least unused short sequence currently in the reservoir and we use long
sequences to define φ(k)for all other elements discovered in T. ◀
C Proof of Theorem 6
▶Theorem 6. The class of r.p.o. trees is punctually robust and P-TIME robust.
Proof.Firstly, we give a detailed proof for the case of punctual robustness.
We fix an infinite computable r.p.o. tree T. We choose a primitive recursive approximation
(Ts)s∈Nof the treeTsatisfying the following properties:
everyTsis a finite tree and T=/uniontext
s∈NTs;
r∈Ts⊆Ts+1andcard(Ts+1\Ts)≤1for alls∈N.
Intuitively speaking, (Ts)s∈Nis a punctually non-decreasing sequence of finite trees such that
for eachs, eitherTs+1is equal toTs, orTs+1is obtained by appending only one new node
toTs.
We want to construct a punctual tree R∼=T. IfThas an infinite depth, then the
existence of such a tree Rfollows from Theorem 12.
Otherwise, the depth of the tree Tis finite. SinceTitself is infinite, there exists a node
a∈Twhich has infinitely many children. Here our construction is split into two cases.
Case A. Suppose that there exists a node a∈Twith the following property:
(‡)ahas infinitely many children xsuch thatxalso has its own child.
In particular, this implies that ahas infinitely many grandchildren which are pairwise
incomparable with respect to the ordering <T. Without loss of generality, we assume that
a∈T0.
The construction proceeds in stages. At a stage s, we build a finite structure Rs. We
also construct a partial isomorphic embedding ψs:⊆Rs→Ts. In the limit, the map
ψ=/uniontext
s∈Nψswill be a computable isomorphism from the tree R=/uniontext
s∈NRsontoT.
The intuition behind the construction is as follows. In order to ensure the punctuality of
the constructed structure R, we ‘quickly’ produce some (intended) grandchildren d0,d1,d2,...
of the node ψ−1(a)which are pairwise <R-incomparable. Inside R, wedo not connect a
nodedito (the component of) the node ψ−1(a)until we see an appropriate isomorphic image
N. Bazhenov, D. Kalociński, and M. Wrocławski 25
z=ψ(di)inTs. (In particular, at some stages sthe structureRswill be a finite forest that
is not a tree.) Only after we find such an image z, we add a fresh node eitoRand declare
P(di,ei) &P(ei,ψ−1(a))insideR(i.e., we make dia ‘real’ grandchild of ψ−1(a)).
Our construction of Rproceeds as follows. At stage 0we putR0=T0andψ0= idT0.
In addition, at the end of each stage s, we choose the least natural number xwhich
currently does not belong to Rs. We define ds=xand adddstoRs. For eachy∈Rs\{ds},
we declare that yis<R-incomparable with dsand that¬P(y,ds) &¬P(ds,y).
At a stages+ 1, we find the least i≤ssuch thatψs(di)is undefined. Suppose that the
treeTs+1contains nodes y,z̸∈range (ψs)such thatT |=P(z,y)&P(y,a)(i.e.,yandzare
‘unaccounted’ child and grandchild of a, respectively). Then we proceed as follows:
Choose the least natural number ei̸∈Rsand addeitoR. Declare that diis a child of
eiandeiis a child of ψ−1(a).
Putψs+1(di) =zandψs+1(ei) =y.
If needed, extend the current Rs+1to ‘mimic’ the finite tree Ts+1. More formally, we add
(the least unused) numbers to Rs+1in such a way that the current map ψs+1could be
extended to an isomorphism ξbetween the trees Rs+1\{dk:k≥i+ 1}andTs+1. Put
ψs+1=ξ. Notice that now we have Ts+1⊆range(ψs+1).
IfTs+1does not have such nodes y,z, then go to stage s+ 2.
This concludes the description of the construction. Observe that the construction of
the structureR=/uniontext
s∈NRsis punctual. Let Abe the connected component of Rwhich
containsψ−1(a). The properties of the construction immediately imply that every node
fromR\{di:i∈N}belongs toA. In addition, the map ψ=/uniontext
s∈Nψsis an isomorphic
embedding fromAtoT.
Since the node ahas Property (‡), there exist infinitely many stages s+ 1such that the
treeTs+1contains the needed nodes yandz. Therefore, we conclude that every element di
belongs toA, and hence, we have A=R. In addition,T=/uniontext
s∈NTs⊆range (ψ). We deduce
thatψis a computable isomorphism from RontoT. Therefore,Ris a punctual copy of the
treeT.
Case B. Otherwise, we can choose a node a∈Tsuch thatahas infinitely many children
and only finitely many children of ahave their own children. We fix the list of all children
ofawhich have their own children: u0<Tu1<T···<Tuk. Again, we assume that
a,u0,u1,...,uk∈T0.
Without loss of generality, we may assume that the interval (u0;u1)T={x:u0<T
x<Tu1}is infinite. Notice that every element x∈(u0;u1)Tdoes not have children. By
Theorem 1.5 of [ 28], we can choose a punctual isomorphic copy L= (N,<L)of the linear
ordering ((u0;u1)T,<T).
The intuition behind the construction is as follows: in order to ensure the punctuality
of the constructed structure R∼=T, we ‘quickly’ produce a copy of the interval (u0;u1)T.
This procedure works by promptly introducing fresh elements d0,d1,d2,...which ‘copy’ the
punctual linear ordering L.
Our construction proceeds in stages. At a stage s, we build a finite tree Rsand an
isomorphism θsfromTs\(u0;u1)TontoRs\(θ(u0);θ(u1))R.
At stage 0we putR0=T0andθ0=id↾(T0\(u0;u1)T). At the end of each stage s, we
choose the least natural number xwhich currently does not belong to Rs. We putds=x
and adddsintoRs. We declare that:
dsis a child of θ(a),
dsdoes not have any children in R,
26 Online and Feasible Presentability: From Trees to Modal Algebras
θ(u0)<Rds<Rθ(u1),
di<Rdjif and only if i<Lj, for alli,j∈N.
Recall that card(Ts+1\Ts)≤1.
Consider a stage s+ 1. Suppose that there exists a (unique) element v∈Ts+1\Ts
additionally satisfying v̸∈(u0;u1)T. Then we choose the least unused number yand add
thisytoRs+1in such a way that the map θs+1=θs∪{(v,y)}becomes an isomorphism
fromTs+1\(u0;u1)TontoRs+1\(θ(u0);θ(u1))R. If there is no such v, then proceed to
stages+ 2.
This concludes the description of the construction. Observe that the construction of
R=/uniontext
s∈NRsis punctual. In addition, the properties of the construction immediately imply
that the map θ=/uniontext
s∈Nθsis a computable isomorphism from the tree T\(u0;u1)Tonto
R\(θ(u0);θ(u1))R.
Since the ordering ({di:i∈N},<R)is isomorphic to L∼=((u0;u1)T,<T), we deduce
that the structure Ris a punctual copy of the tree T.
Now we show how the proofs of Case A and Case B could be adapted to provide P-TIME
robustness. Here we describe only the key modifications of the constructions for Cases A
and B.
We need to build a P-TIME structure Rsuch thatR∼=TandRhas domain B={0,1}<ω.
As in the P-TIME construction of Theorem 12, at each stage swe perform a fixed number l
of steps of the algorithm which calculates the computable tree T.
(A) Fors∈N, the intended grandchild dsshould be chosen as the ⊏-least string αwhich
currently does not belong to Rs. The element dsis then declared a ‘short’ string, and short
strings are essentially used to construct the ‘reservoir set’ (in terminology of the construction
of Theorem 12). All the other nodes which are added to Rs+1(i.e., the node eiand nodes
which help to mimic Ts+1) must be chosen as long enough strings.
(B) We note that Grigorieff [ 25] proved that every infinite computable linear ordering
has an isomorphic P-TIME copy with domain B(see also Theorem 4.8 in [ 11]). Hence, we
can choose a P-TIME linear ordering L= (B,<L)which is isomorphic to the structure
((u0;u1)T,<T). Observe that now the set Bhas two P-TIME orderings: <Land⊏.
At a stages, the nodedsmust be chosen as a short string (i.e., the ⊏-least string αwhich
currently does not belong to Rs). Thisdswill serve as the ‘copy’ of the string βswhich is
thes-th least string with respect to ⊏from dom(L) =B. In order to copy the relation <L,
we putdi<Rdjif and only if βi<Lβj. The nodes ds,s∈N, are used to construct the
reservoir set. All the other nodes from R(i.e., the nodes yfrom the construction which are
added to someRs+1) are chosen as long strings.
In this case we are going to introduce a certain modification to the proof of the lemma
that relations on this tree are P-TIME. We observe that the ordering on the interval
I= (θ(u0);θ(u1))R(consisting of short strings) has some polynomial bound V(n)and all
the relations on the part of the tree Routside of that interval (consisting of long strings)
have some polynomial bound W(n). The only case when a short and a long string are in
a relation is when a short string from Iis a child of a long string θ(a). All such cases are
verifiable in time bound V(n).
To decide if aandbare in some relation, with lh(a)≤lh(b) =nwe perform the
construction until s0– the later of steps V(n)andW(n). The elements are in the relation
only if this is established at the latest at step s0. The proof that this can be done in
polynomial time is very similar to the case of trees of unbounded depth.
The described modifications could be formalized to provide a P-TIME structure R∼=T
with dom(R) =B. ◀