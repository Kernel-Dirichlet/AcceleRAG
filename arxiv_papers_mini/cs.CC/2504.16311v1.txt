arXiv:2504.16311v1  [cs.CC]  22 Apr 2025Key-agreement exists if and only if the “interactive vs non
interactive Kolmogorov problem” is not in ioBPP: a short
proof
Bruno Bauwens and Bruno Loﬀ
April 24, 2025
Abstract
Ball, Liu, Mazor and Pass [BLMP23] proved that the existence of key-agreement protocols
is equivalent to the hardness of a certain problem about inte ractive Kolmogorov complexity.
We generalize the statement and give a short proof of the diﬃc ult implication.
This note is self-contained, all deﬁnitions are given in Section 1. The d eﬁnitions are simpler than
those of [BLMP23], yet give a stronger result. The proof of the equ ivalence has two directions.
One direction is almost the same as in [BLMP23], so we include it in Appendix D. The other
direction is proven in Section 2.
1 Preliminaries
In a key agreement protocol, Alice and Bob exchange messages via a public channel, with the
goal of generating a shared secret: a private, random string kno wn only to them. Any third party
who sees their communication should be unable to guess the shared s tring, except perhaps with
negligible probability. We may formalize this as follows.
– There are two randomized algorithms A and B, which are given the sa me input n. They interact
by alternatingly sending a single bit. While an algorithm computes its rep ly, the other is idle.
At some point both algorithms terminate. Then, the transcript πof their interaction is the
string of exchanged bits.
– Each algorithm also produces a private output string. Let xandybe these outputs. They are
the two versions of the secret key, (and hopefully, x=y).
– Aprotocolis a mapping from nto a random triple ( π,x,y) generated by some algorithms A and
B in this way. The protocol is t-time bounded fort:N→Nif there exist such A and B with
runtime O(t(n)).
Deﬁnition 1.1. Letα,ε:N→[0,1]. We say that a protocol n/ma√sto→(π,x,y):
•hasagreement αif for large n: Pr[x=y]≥α(n),
•isε-secureif for every probabilistic polynomial time algorithm Eand large n:1
Pr[E(0n,π)=x]≤ε(n).
1In some references, like [IR89, BLMP23], algorithm Edoes not have nas input. This is meaningless because
the following protocol would be a key-agreement one. Alice a nd Bob have no communication, thus π=“empty
string”, and x=y=n. SinceEhas the empty string as input and is time bounded, with probab ility 1, its output
is bounded by a constant, and therefore wrong for large n.
1
Akey-agreement protocol is a protocol that is nO(1)-time bounded, has agreement 1 −1
ncand is
1
nc-secure for all c.
A fundamental open problem in cryptography is whether there exis ts a key-agreement protocol.
In [BLMP23], an equivalent problem is given in terms of interactive Kolmo gorov complexity.
TheKolmogorov complexity ofxgivenyis C(x|y) = min {|p|:M(p,y) =x}, where Mis a
machine that minimizes the function C up to an additive constant.
LetUandVbedeterministic Turing machines with a private input, work and output tapes,
and a shared communication tape. Let U(a)↔V(b) denote the triple ( π,x,y) obtained as follows.
Initially, both machines have programs aandbon their respective input tapes. Machines
UandValternatingly calculate a single bit and communicate it by writing it on the shared
communication tape. After both machines halt, πis the binary string of communicated bits, and
x,yare the contents of UandV’s private output tapes.
Deﬁnition 1.2. Thet-time-bounded interactive Kolmogorov complexity of a pair ( π,x) relative
to machines U,Vis
CIt
U,V(π,x) = min/braceleftBig
|ab|: (π,x,x) =U(a)↔V(b)/bracerightBig
,
where both UandVterminate after at most t(|πx|) steps.
The pair U,Visoptimalfor this complexity if for every other pair /tildewideU,/tildewideVthere exists a constant c
satisfying
∀π,x,t: CIctlogt
U,V(π,x)≤CIt
/tildewideU,/tildewideV(π,x)+c.
We ﬁx such U,Vand drop the subscripts from CIt. The special case of interactive complexity for
x= “empty string” and t= +∞was ﬁrst studied in [CSVV08] and shown to exceed C( π)+Ω(|π|)
for some πin [Bau14].
Deﬁnition 1.3. Apromise problem is a pair ( Y,N) of sets. A problem ( Y,N) is inioBPPif
there exists a probabilistic polynomial time algorithm Aand inﬁnitely many nsuch that
•for allz∈ Y ∩{0,1}n: Pr[A(z) = “outside N”]≥2/3, and
•for allz∈ N ∩{0,1}n: Pr[A(z) = “outside Y”]≥2/3.
Foriocomplexity classes, the representation is important in ways that ar e not for normal com-
plexity classes; for example, if all representations have odd length then the problem is trivially
inioBPP. So, for concreteness, we will represent a pair ( π,x) of Boolean strings by 0 π1···0π|π|1x,
thus|(π,x)|=|ππx|+1.
All results also hold with a more robust variant of ioBPP. We say that a problem is in interval-
ioBPPif there exists a function f(n)≤o(n) such that the 2 requirements of deﬁnition 1.3 hold
for inﬁnitely many nand allzwithf(n)≤ |z| ≤n. Being interval- ioBPPis invariant under linear
time transformations of the representation.
The following is a simpler version of the main result of [BLMP23].
Theorem 1.4. Letc >0,e > c+3,t(n)∈ω(nlogn)witht(n)≤nO(1)and
Yt
c={(π,x) : CIt(π,x)≤C(π)+clog|πx|}
Ne={(π,x) : C(π,x)≥C(π)+elog|πx|}.
A key-agreement protocol exists if and only if the promise pr oblem(Yt
c,Ne)is not in ioBPP.
We make several useful remarks about this theorem in Appendix A, where we also prove that
it implies theorem 3.4 in [BLMP23].
More remarks.
2
– The theorem also holds if we replace the set Neby{(π,x) : C(x|π)≥elog|πx|}.
– It also holds if we use interval- ioBPPinstead of ioBPP.
– We will prove the theorem for the special case that c >3 ande > c+6. The proof with better
parameters is outlined in the footnotes.2
The proof that nonexistence of key-agreement implies that ( Yt
c,Ne) is inioBPP, is the same as in
[BLMP23], so we include it in Appendix D. We now prove the other directio n.
2 Algorithms for (Yt
c,Ne)can break key-agreement
Proposition 2.1. Letc >3andt(n)∈ω(nlogn). If(Yt
c,Ne)is inioBPP, then there exists no
key-agreement protocol.
Using the Goldreich-Levin theorem it is possible to prove that, if a sec ure key-agreement protocol
exists, i.e. where Eve cannot guess the entire key, then a strongly secure key-agreement protocol
exists, where Eve cannot even distinguish the agreed-upon key fr om a uniformly random string.
Deﬁnition 2.2. Letε:N→[0,1]. We say that a protocol n/ma√sto→(π,x,y)has leakage εif there
exists a probabilistic polynomial time algorithm Eand inﬁnitely many nsuch that
/vextendsingle/vextendsingle/vextendsinglePr[E(π,x)]−Pr[E(π,U)]/vextendsingle/vextendsingle/vextendsingle> ε(n),
whereUis a random string in {0,1}|x|.
In the above deﬁnition, conditional to |U|=|x|, stringUis independent of the protocol. For
technical reasons, we consider leakage in protocols that satisfy a dditional assumptions.
Deﬁnition 2.3. We say that a protocol n/ma√sto→(π,x,y) isstandard if|(π,x)|=n, it has run-
timeO(n), it has (1 −1/nω(1))-agreement, and the amount of randomness used by Alice and by
Bob only depends on n.
The following is proven in Appendix B.
Corollary 2.4 (of[GL89, Yao82]) .Suppose that there exist positive ǫ,b,dsuch that every standard
protocol with |x| ≥dlog|πx|and which uses at most nǫbits of randomness, has leakage 1/nb. Then
key-agreement does not exist.
We will prove that an algorithm for the ( Yt
c,Ne) problem can be used to break all protocols in
the above sense, that it can distinguish the agreed key from a rand om string. This is easy to show
for a speciﬁc type of protocol. Recall that a protocol is a randomiz ed algorithm, hence, it induces
a map from the chosen randomness by Alice and Bob to transcripts. In [BLMP23] a protocol is
called Diﬃe-Hellman-like if this map is bijective.
Deﬁnition 2.5. A protocol is DH-likeif for every nthe map ( rA,rB)/ma√sto→πis bijective.
Lemma 2.6. Letc >3,d > eandt(n)≥ω(nlogn). If(Yt
c,Ne)is inioBPP, then every DH-like
standard protocol with |x| ≥dlog|πx|has leakage Ω(1).
Proof.Letn/ma√sto→(π,x,y) be a DH-like standard protocol with |x| ≥dlog|πx|. We need to show
that Eve behaves diﬀerently when given the key xvs a random string Uof length |x|.
LetDbeanioBPP-deciderfor( Yt
c,Ne) andnbealargelengthforwhichthe ioBPPrequirement
holds for all ( π,x) with|(π,x)|=n. We prove that
Pr[D(π,x)=“outside N”]−Pr[D(π,U)=“outside N”]≥1
3−2
100.
2A variant with preﬁx-free complexity with |π|in the condition holds for all 0 < c < e.
3
Right probability. Recall that Uis independent of πconditional to |U|. Hence, with probability
1−1
100,
C(π,U)−C(π)+O(1)≥ |U|=|x| ≥dlog|πx|.
Thus, (π,U)∈ Nesinced > eandnis large. Hence, Danswers “outside N” with probability at
most1
3+1
100, since|(π,U)|=n.
Left probability. Letaandbbe the randomness used by Alice and Bob to obtain ( π,x,y) on
inputn. We prove that with probability 1 −1
100and up to O(1) terms:
CIt(π,x)−(2+o(1))log|πx| ≤ |ab| ≤C(ab|n) = C(π|n)≤C(π).
This implies that ( π,x) is inYt
c, sincec >2. Thus, Danswers “outside N” with probability
almost2
3.
The left inequality holds with probability 1 −1/nω(1), because programs for aandbin the
deﬁnitionofinteractivecomplexitycanbeobtainedfromtherandom nessofAliceandBobtogether
with an encoding of n, (thus both to Alice’s and Bob’s randomness, a description of nin binary
is prepended). Note that Bob’s key indeed equals Alice’s key xwith probability 1 −1/nω(1). Also
note that the runtime of the protocol is O(|πx|), because it is standard. Since t(n)≥ω(nlogn),
this computation can be simulated on the optimal pair ( U,V) in the deﬁnition CI.
The 2nd inequality holds with probability 1 −1
200, since for ﬁxed n, the randomness aandb
has a ﬁxed length, by deﬁnition of being standard. The equality follow s by bijectivity of DH-like
protocols. The chain of (in)equalities and the lemma are proven.
Already[BLMP23]hadobservedthatproposition2.1canbeeasilypro venforDH-likeprotocols.
It is easy to transform any protocol to an approximately DH-like pr otocol by letting Alice and Bob
sending a long enough hash value of their randomness. But in genera l, the breaker only has the
transcript of the original protocol. How can he add hash values to s imulate the modiﬁed protocol?
The idea is that a short enough hash value looks random (by the left- over-hash lemma). Thus,
the breaker Emay replace hash values by random strings and then call the decider of (Yt
c,Ne).
The length of the hashes should be just right: short enough to look random, and long enough so
that the simulated protocol is approximately DH-like. The idea is to gu ess these lengths. The
probability of guessing correctly will be proportional to the leakage .3
Proof of Proposition 2.1. LetDbe a decider for ( Yt
c,Ne) that for inﬁnitely many manswers
correctly on m-bit inputs with probability 1 −o(1/m). (As usual, by repeated trials we may
indeed assume that the success probability is very close to 1.) Suppo se that this happens for
inﬁnitely many evenm. If this is not the case, apply the padding in algorithm Ebelow to length
2n+1 instead of 2 n.
Fork≤ρ, letHρ,kbe a universal set of hash functions from {0,1}ρto{0,1}k. Assume that
log|Hρ,k| ≤O(ρ2) and that each h∈Hρ,kis represented as a string of length log |Hρ,k|+O(1).
Say, we hash with random k×ρbinary matrices, for which |h|=ρk≤ρ2.
Note that in a reduction to the ioBPP-decider D, the length needs to be carefully controlled,
and this forces a discussion of some details. Our choice of represen tation of pairs has |(π,z)|=
2|π|+1+|z|. Forℓ≥ |(π,z)|, let (π,z):ℓbe thepadded pair (π′,z′) such that |(π′,z′)|=ℓ, string
z′extendszby at most 1 bit and π′=π10kfor the appropriate k.
Letπ/an}⌊ra⌋k⌉tl⌉{th,g,w,v/an}⌊ra⌋k⌉tri}htbe the transcript in which ﬁrst Alice and Bob exchange π. Then Alice sends
h, bit by bit, while Bob replies with 0’s. Afterwards Bob sends gin a similar way, and this is
repeated with w, sent by Alice, and v, sent by Bob.
Finally, let ǫ >0 be small enough such that c >3+4ǫandǫ <1/2.
3It seems that in [BLMP23], hash functions are used from a set o f size poly( n), which is small. The ﬁrst author
recognizes some similarities to the construction of disper sers in [TSUZ07], which are also used to obtain hash
functions from a set of size n8constructed in [Teu14, BMVZ18]. In fact, the argument can be ﬁnished more brieﬂy
using these hashes, but it requires c >19. Below we give an elementary proof, which works with any un iversal set
with 2O(n)hash functions. We will use the smaller size 2O(n2ǫ)withǫ <1/2 to avoid technicalities regarding the
runtime of computing hashes and to obtain theorem 1.4 for any c >0, (as explained in the footnotes).
4
Predicate E(π,z).Letn=|(π,z)|andρ=⌊nǫ⌋. Randomly select α,β∈[ρ] (the unknown hash
lengths), h∈Hρ,α,g∈Hρ,β(the hash functions), and w∈ {0,1}αandv∈ {0,1}β(the presumed
hash values of rAandrB). Output 1 if
D/parenleftbig
(π/an}⌊ra⌋k⌉tl⌉{th,g,w,v/an}⌊ra⌋k⌉tri}ht,z):2n/parenrightbig
answers “outside N”, and otherwise, output 0.
Notethatthe paddingtolength2 nispossiblebecause h,g,w,v allhavebitsizeatmost n2ǫ≤o(n).
Hence,|(π/an}⌊ra⌋k⌉tl⌉{th,g,w,v/an}⌊ra⌋k⌉tri}ht,z)| ≤n+o(n)≤2nfor large n.
Letd > e+2ǫ. Letn/ma√sto→(π,x,y) be standard with |x| ≥dlog|πx|and generated with at most
ρ=⌊nǫ⌋random bits.
We prove that the protocol has Ω(1 /n2ǫ)-leakage. Thus for inﬁnitely many n,
Pr[E(π,x)]−Pr[E(π,U)]≥Ω(1/ρ2). (1)
This implies the condition of Corollary 2.4 and hence Proposition 2.1. Let nbe large such that D
is correct with probaiblity o(1/n) on inputs of length n.
Claim. Pr[E(π,U)]≤o(1/ρ2).
The analysis is similar to before. Let (˜ π,˜U) be the input given to the decider Din algorithm E.
Note that ˜Ueither equals UorUwith a single bit appended. With probability 1 −o(1/ρ2) over
the choice of U,
C(˜π,˜U)−C(˜π)≥ |U|−(2ǫ+o(1))logn≥(d−2ǫ−o(1))log|˜π˜U|.
Thus, (˜π,˜U)∈ Nefor large n, by choice of d > e+2ǫ. Hence, the ioBPPdecider outputs “outside
N” with probability o(1/ρ2). This implies the claim.
Claim. Pr[E(π,x)]≥Ω(1/ρ2).
It remains to prove this claim, since both claims together, imply inequa lity (1).
We view wandvas hashes. For A⊆ {0,1}ρ, ﬁx any pseudo inverse of hinA, say the one
based on the lexicographic ﬁrst match in A, thus
h−1
A(w) = min{a∈A:h(a) =w},
when deﬁned. Note that it may be undeﬁned. Similar for g−1
A.
LetAπ⊆ {0,1}ρbe the set of Alice’s random strings that are compatible with her replie s inπ.
LetBπbe deﬁned similarly for Bob’s randomness. These sets are computab le givenπandn.
The input of the decider DinEis
(˜π,˜x) = (π/an}⌊ra⌋k⌉tl⌉{th,g,w,v/an}⌊ra⌋k⌉tri}ht,x):2n.
We prove that with probability Ω(1 /ρ2), the values
a=h−1
Aπ(w) and b=g−1
Bπ(v)
are deﬁned and satisfy up to o(logn)-terms,
CIt(˜π,˜x)−(2+4ǫ)logn≤ |hagb| ≤C(h,a,g,b)≤C(˜π)+logn. (2)
Sincec >3+4ǫ, this implies (˜ π,˜x)∈ Yt
cwith probability Ω(1 /ρ2). Hence, for inﬁnitely many n,
the decider outputs “outside N” with probability Ω(1 /ρ2). This implies the claim. It remains to
prove that each of the 3 inequalities from (2) holds with probability Ω( 1/ρ2) for alln.
•Let EH be the event that the hash sizes in algorithm Eare correct, thus that α=⌊log|Aπ|⌋
andβ=⌊log|Bπ|⌋. This happens with probability 1 /ρ2.
5
•The following lemma implies that conditional to EH, with probability Ω(1), the values aandb
are deﬁned and satisfy C( hagb)≥ |hagb|−O(1), i.e., the middle inequality of (2).
Lemma 2.7. Consider a partition of a ﬁnite set Rinto a family of sets Aπ×Bπfor allπ. For
eachπ, letHπandGπbe universal sets of hash functions mapping AπtoWπ={0,1}⌊log|Aπ|⌋
andBπtoVπ={0,1}⌊log|Bπ|⌋.
Select a random πwith probability |Aπ×Bπ|/|R|. Also select random h∈Hπ,w∈Wπ,g∈Gπ,
v∈Vπ. With probability Ω(1), the following inequality is deﬁned and is true:
C(h,h−1
Aπ(w),g,g−1
Bπ(v))≥log(|Hπ|·|Gπ|·|R|)−5.
The lemma is proven in Appendix C. It is applied to R={0,1}ρ× {0,1}ρ(Alice and Bob’s
randomness), Hπ=Hρ,⌊log|Aπ|⌋andGπ=Hρ,⌊log|Bπ|⌋. Event EH implies that Wπ={0,1}α
andVπ={0,1}β. Thus, the distribution of π,h,w,g,v in Lemma 2.7 is the same as in E
conditional to event EH. The middle inequality of (2) is proven.
•Given ˜π,none can compute AπandBπ. The right inequality of (2) follows by the choice of a
andb, assuming that they are deﬁned.
•Let EA be the event that x=y. By agreement, EA happens with probability 1 −1/nω(1).
•We prove the left inequality of (2) conditional to event EA.
Alice knows n,a,α,h, and Bob n,b,β,g. Together they possess |ahbg|+(2+4 ·ǫ+o(1))logn
bits of information. They generate the transcript π/an}⌊ra⌋k⌉tl⌉{th,g,w,v/an}⌊ra⌋k⌉tri}htin the logical way. First they
simulate the protocol and obtain π. Then, they send h,g,v,w in turns, where wis theα-bit
hash ofaand similar for v. Using n,πand their randomness, they each obtain x, (assuming
EA). It remains to add the padding to obtain ˜ π,˜x.
Recall that ǫ <1/2. The above procedure runs in time O(n), for example for hashing with
random matrices using Hρ,k={a/ma√sto→Ma:M∈ {0,1}k×ρ}.Note that evaluating Matakes
timeO(kρ)≤O(n2ǫ)≤o(n). The optimal machines ( U,V) in the deﬁnition of CI simulate
everything in time O(nlogn). Sincet(n)≥ω(nlogn), the inequality holds.
In summary, conditional to eventsEA and EH, all requirementsare satisﬁed with probabilityΩ(1).
Since EA and EH happen simultaneously with probability Ω(1 /ρ2), this implies the chain (2) and
the claim. Proposition 2.1 is proven.4
References
[AB09] Sanjeev Arora and Boaz Barak. Computational Complexity - A Modern Approach .
Cambridge University Press, 2009.
[Bau14] Bruno Bauwens. Asymmetry of the kolmogorov complexity o f online predicting odd
and even bits. In 31st International Symposium on Theoretical Aspects of Com puter
Science, page 125, 2014.
4Recall that proposition 2.1 assumes c >3. To prove it for c >0, note that the excess term in the left and right
inequality of (2) is needed for providing n. One might think that nshould be included in the transcript, so that
it also increases the right side of the inequality. This solv es the problem for the right inequality. But this is not
enough for the left one, because of the time bound in CItandnmight be computationally deep. The solution is to
make the program length reveal n.
In the construction of E, we prepend a random string sof length n/2 to the transcript ˜ π. Only the length of s
will be used. Let ¯ abe a preﬁx code of length |a|+ 2log|a|+ 1. Now Alice’s program is ¯ a¯α¯hs, which has length
|ahs|+O(ǫlogn). Note that sis not given in a preﬁx way. In the beginning, Alice strips the 3 preﬁx codes from the
program to obtain s. She sends sto Bob. They both use n= 2|s|orn= 2|s|+1, depending on whether there are
inﬁnitely many even or odd nfor which the decider works. Then the protocol and the analys is proceeds as before.
This removes the 2log nand lognterms from the left and the right inequalities in (2).
6
[BGRS22] Bruno Bauwens, Peter G´ acs, Andrei Romashchenko, a nd Alexander Shen. Inequalities
for space-bounded kolmogorov complexity. Computability , 11:165–185, 2022.
[BLMP23] Marshall Ball, Yanyi Liu, Noam Mazor, and Rafael Pass. Ko lmogorov comes to cryp-
tomania: On interactive kolmogorov complexity and key-agreement . InProceedings of
the 64th IEEE Symposium on Foundations of Computer Science , pages 458–483, 2023.
[BMVZ18] Bruno Bauwens, Anton Makhlin, Nikolai K. Vereshchagin, a nd Marius Zimand. Short
lists with short programs in short time. Computational Complexity , 27(1):31–61, 2018.
[BS13] Bruno Bauwens and Alexander Shen. An additivity theorem fo r plain Kolmogorov
complexity. Theory of Computing Systems , 52(2):297–302, Feb 2013.
[CSVV08] Alexey Chernov, Alexander Shen, Nikolay Vereshchagin, a nd Vlademir Vovk. On-line
probability, complexity and randomness. In ALT ’08: Proceedings of the 19th interna-
tional conference on Algorithmic Learning Theory , pages 138–153, Berlin, Heidelberg,
2008. Springer-Verlag.
[GL89] O. Goldreich and L. Levin. A hard-core predicate for all one- way functions. In Pro-
ceedings of the 21st ACM Symposium on Theory of Computing , pages 25–32, 1989.
[Hol05] Thomas Holenstein. Key agreement from weak bit agreement . InProceedings of the
thirty-seventh annual ACM symposium on Theory of computing , pages 664–673, 2005.
[Hol06] Thomas Holenstein. Strengthening key agreement using hard-core sets . PhD thesis,
ETH Zurich, 2006.
[IR89] Russell Impagliazzo and Steven Rudich. Limits on the provable consequences of one-
way permutations. In Proceedings of the twenty-ﬁrst annual ACM symposium on The-
ory of computing , pages 44–61, 1989.
[Lon86] Luc Longpr´ e. Resourcebounded kolmogorovcomplexity, a link between computational
complexity and information theory. Technical report, Cornell Univ ersity, 1986.
[Teu14] Jason Teutsch. Short lists for shortest descriptions in sh ort time. Computational
Complexity , 23(4):565–583, 2014.
[TSUZ07] A. Ta-Shma, C. Umans, and D. Zuckerman. Lossless cond ensers, unbalanced ex-
panders, and extractors. Combinatorica , 27(2):213–240, 2007.
[Yao82] A. Yao. Theory and application of trapdoor functions. In Proceedings of the 23rd
IEEE Symposium on Foundations of Computer Science , pages 80–91, 1982.
A Remarks about the (Yt
c,Ne)problem
Recall that
Yt
c={(π,x) : CIt(π,x)≤C(π)+clog|πx|}
Ne={(π,x) : C(π,x)≥C(π)+elog|πx|}.
– The problem ( Yt
c,Ne) depends on 3 parameters: c,e,t. Decreasing cort, or increasing e, can
only make the problem easier to solve (because this makes the sets s maller). Theorem 1.4
implies that for all c,e,tsatisfying the conditions, either all problems ( Yt
c,Ne) are inioBPPor
none are.
7
– Ifr >1, then the set Yt
c∩Nc+ris ﬁnite, because
CIt(π,x)≥C(π,x)−(1+o(1))log|π|
holds by concatenating programs and adding a preﬁx free descript ion of the splitting point.
Thus for e > c+1, the promise problem cannot be trivially excluded from ioBPP.
Lemma A.1. Ifr >3, then the problem (Yt
c,Nc+r)can be solved in space O(tlogt).
Proof.For an integer s, let Cs
sp(···) be the Kolmogorov complexity on a reference machine with
programs that use scells on a binary work tape. Symmetry of information holds with a spac e
bound:
Cs′
sp(π)+Cs′
sp(x|π)≤Cs
sp(π,x)+(1+o(1))(logCs
sp(π)+logCs(x|π)),
wheres′= 3s+10|π|. This follows from the standard argument of symmetry of informat ion and
careful handling of the logarithmic terms. (See [Lon86, theorem 3.1 3, p35] or [BGRS22, theorem
1] for recent improvements on s′. Note that some parameters are almost equal to the program
lengths, see [BS13, proposition 2]).
Letε >0 be small such that 2 ε < r−3. Let ˜cbe a constant that we choose later.
Algorithm on input (π,x).Letn=|πx|ands′= 3˜c·t(n)logt(n)+10n. If
Cs′
sp(x|π)≤(c+2+ε)log|π|, (3)
then answer “outside N”, otherwise, answer “outside Y”.
We verify correctness. If the algorithm outputs “outside N”, then inequality (3) holds. Thus,
C(π,x)< C(π)+C(x|π)+(1+ε)logn≤C(π)+(c+r)lognholds, and indeed, ( π,x) is outside Ne.
Letd= Cs′
sp(x|π)−(c+ 2 +ε)logn. If the algorithm outputs “outside Y”, thend >0.
Space-bounded symmetry of information implies
(c+2+ε)logπ+C(π) = Cs′
sp(x|π)+C(π)−d
≤Cs
sp(π,x)+(1+o(1))(logn+logd)−d
≤CIt(π,x)+(2+o(1))logn,
wheres= ˜c·t(n)logt(n) and ˜cis chosen large enough for the simulation of the optimal pair ( U,V)
in CI. This implies ( π,x)/n⌉}ationslash∈ Yt
c. Thus also if the algorithm outputs “outside Y”, it is correct.
The main result of [BLMP23] considers a similar problem on triples ( π,x,y). We explain that it
is a corollary of theorem 1.4. For d >0, let
CIt(π,x,y) = min{|ab|: (π,x,y) =U(a)↔V(b) in time t(|π|)}
Qt
d={(π,x,y) :|π|=|x|=|y|and max(Ct(x|y),Ct(y|x))≤dlog|π|},
andQ0={(π,x,x) :|π|=|x|}.
Theorem A.2 ([BLMP23]) .Letd≥0,c >3,e−c >9 + 2dandt(n) =nγfor some γ >1.
Key-agreement exists if and only if the promise problem
/tildewideYt
c,d=Qd∩{(π,x,y) : CIt(π,x,y)≤C(π)+clog|π|}
/tildewideNe,d=Qd∩{(π,x,y) : C(π,x,y)≥C(π)+elog|π|}
is not in ioBPP.
8
Proof using theorem 1.4. Assume 0 < ε < c −3. If (π,x)∈ Yt
cand|π|=|x|, then (π,x,x)∈
/tildewideYt
c+ε,d. Similarly, if ( π,x)∈ Ne, then (π,x,x)∈/tildewideNe−ε,d.
Thus, if ( /tildewideYt
c,d,/tildewideNe,d)∈ioBPP, then the variant of the ( Yt
c+ε,Ne−ε) with|π|=|x|is inioBPP.
But then for s=nγ−ε, also (Ys
c+2ε,Ne−2εis inioBPP, because we can padd the shorter string of
the pair and this aﬀects the complexities by O(1). By theorem 1.4, key-agreement does not exist.
Now the other direction is proven.
Claim. Ifs≥ω(tlogt)and(Ys
c+d+ε,Ne−d−ε)∈ioBPP, then(/tildewideYt
c,d,/tildewideNt
e,d)∈ioBPP.
Proof.This follows from
(π,x,y)∈/tildewideYt
c,d=⇒(π,x)∈ Ys
c+d+ε
(π,x,y)∈/tildewideNt
e,d=⇒(π,x)∈ Ne−d−ε.
For the ﬁrst implication, observe that
CIs(π,x)≤CIt(π,x,y)+(1+o(1))Ct(y|x).
Indeed, “Bob’s” program bhas output y=V(b,π), so we prepend a program to bthat maps y
tox. By deﬁnition of Qt, we have Ct(y|x)≤dlog|π|. We need a large time bound sto account
for the simulation of the programs on the ﬁxed optimal machines in CI . The ﬁrst implication is
proven.
For the second, note that dropping yin the complexity, can only decrease the complexity by
C(y|π,x) +O(logC(y|π,x)). By deﬁnition of Qd, this is at most ( d+o(1))log|π|. The claim is
proven.
Now we ﬁnish the proof of Theorem A.2. Assume key-agreement doe s not exist. By Theorem 1.4
this implies ( Ynγ
c+d+ε,Ne−d−ε)∈ioBPPfor every γ >1. By the claim, this implies ( /tildewideYnγ
c,d,/tildewideNnγ
e,d)∈
ioBPPfor every γ >1.
B Proof of Corollary 2.4
Lemma B.1 ([GL89,Yao82]) .There exists an oracle-aided probabilistic polynomial tim e algorithm
Aand a positive polynomial psuch that the following holds for all integers ℓ,n, allα >0, all
distributions Qover{0,1}∗×{0,1}n, and every polynomial time algorithm E. If
/vextendsingle/vextendsingle/vextendsinglePr/bracketleftbig
E(π,r1···rℓ,x⊙r1···x⊙rℓ)/bracketrightbig
−Pr/bracketleftbig
E(π,r1···rℓ,U)/bracketrightbig/vextendsingle/vextendsingle/vextendsingle≥α
for(π,x)∼Qand for uniformly random ri∈ {0,1}n,U∈ {0,1}ℓ, then
Pr
(π,x)∼Q[AE(0n,0ℓ,0/ceilingleftBig1
α/ceilingrightBig
,π) =x]≥p(α,2−ℓ,1
n).
Proof Sketch. Using Yao’s next-bit predictor theorem ( §9.3.1 in [AB09]), we can obtain from E
a randomized predictor P(π,r1,...,r i,r1⊙x,...,r i−1⊙x), such that, for a typical choice of
r1,...,r i−1, when given x⊙r1,...,x⊙ri−1as advice the predictor outputs x⊙riwith probability
1
2+α
ℓover the choice of ri. We are not assuming that Ahas access to x⊙r1,...,x⊙ri−1
for such a typical choice, so we have Asampler1,...,r i−1at random and guess the values of
x⊙r1,...,x⊙ri−1, and with probability Ω(2−ℓ) ther’s are typical and the guess is correct with
probability α/ℓ.
So, conditioned on this event, we have obtained a predictor which allo ws us to output pairs
(r,x⊙r), forrandom r, whicharecorrectwithprobability ≥1
2+α/ℓ. TheGoldreich–Levintheorem
(§9.3.2 in [AB09]) then says that from such a predictor we can obtain a list of size polynomial in
ℓ/α, one of whose elements is x. ThenAoutputs a random element in this list.
9
Proof of Corollary 2.4. Note that the deﬁnition of key-agreement protocol does not cha nge if we
rescalenpolynomially: if for δ >0, on input n, we return the triple ( π,x,y) from the input
nδinstead, then the protocol remains key-agreement. Indeed, if ε(n)< n−cfor allc, then also
ε(nδ)< n−cfor allc. Similar for the neglibility of agreement failure. Hence, it is enough to p rove
that under the assumption of the corollary, there exist no key-ag reement protocols with runtime
at mostnǫ/2. For such protocols, the lengths |x|,|y|,|π|are at most nǫ/2.
Fix such a protocol n/ma√sto→(π,x,y) with agreement 1 −1/nω(1). Consider a new protocol
n/ma√sto→(π′,x′,y′) where Alice and Bob ﬁrst obtain ( π,x,y) on input n. Then Alice sends dlogn
strings of length |x|to Bob, so that π′=πr1...rℓ. Alice’s key is x′=x⊙r1...x⊙rℓand Bob’s
key is similar. This protocol has the same agreement 1 −1/nω(1). To make the protocol standard,
we apply the right amount of padding to π′so that|(π′,x′)|=n. Finally, we ensure that some
amount of randomness is read that only depends on n. Now, the new protocol with mapping
n/ma√sto→(π′,x′,y′) is standard.
By assumption of Corollary 2.4, this protocol has leakage n−b. Thus, there exists an adversary
Ethat distinguishes x′from random with probability-diﬀerence n−b. By lemma B.1, this gives
us an adversary Athat predicts xwith non-negligible probability. Hence, our original protocol
n/ma√sto→(π,x,y) is not a key-agreementone. We conclude that there exist no key- agreementprotocols
with runtime nǫ/2, and hence, no key-agreement protocols in general.
C Proof of Lemma 2.7
Deﬁnition C.1. We say that a variable Visγ-close to uniform inRif its statistical distance to
URis at most γ, whereURis a uniformaly distributed variable in R.
The proof uses the following observations.
(a) LetVbe (γ−δ)-close to uniform in R. IfS⊆Rand|S| ≥γ|R|, then Pr[ V∈S]≥δ.
(b) IfVis (1−2ε)-close to uniform in R⊆ {0,1}∗, then Pr[C( V)≥log(ε|R|)]≥ε.
(c) IfVis uniform in S⊆Rand|S| ≥ε|R|, thenVis (1−ε)-close to uniform in R.
(d) Let sets R1,R2,...partition a ﬁnite set R. For each π, letVπbe a random variable that is
γ-close to uniform in Rπ. LetM=Vπwhereπrandomly selected with probability |Rπ|/|R|.
Then,Misγ-close to uniform in R.
(e) LetHbe a universal set of hash functions from AtoWwith|W| ≤ |A|. For a random h∈H
anda∈A, the pair ( h(a),h)∈W×His supported on a set of size at least1
2|H|·|W|.
(f) LetH,A,W be as in (e). For a random h∈Handw∈W, the pair ( h,h−1
A(w))∈H×Ais
deﬁned with probability 1 /2 and conditional to being deﬁned, it is uniformly distributed on
a set of size1
2|H|·|W|.
Proof.(a) The statistical distance between two measures is the maximal d iﬀerence of the proba-
bilities of some set. Hence, Pr[ V∈S]≥Pr[U∈S]−γ+δ≥δ.
(b) Setγ= 1−εandδ=εin (a). Less than Nstringsxsatisfy C( x)<logN.
(c) Pr[V∈S′]−Pr[UR∈S′] is maximized for S′=S, and this maximum equals 1 −|R|/|S|.
(d) A uniform random variable in Ris obtained as URπ, whereπis selected in the same way. The
statistical distance is now the weighted average of the distances b etweenURπandVπ.
(e) This is a special case of the left-over-hashlemma, see e.g. [AB09 , lemma 21.25 p445]. We prove
it for convenience.
Ifphasdnonzero entries, then ||p||1≤√
d||p||2, (by the Cauchy-Schwartz inequality). Let
pbe the vector whose entries are the probabilities of ( h(a),h) in all elements in W×H. Thus
||p||1= 1.
10
Note that ||p||2
2is the probability that ( h(a),h) = (h′(a′),h′) for an independent copy ( h′,a′)
of (h,a). Ifa/n⌉}ationslash=a′, then Pr[ h(a)=h(a′)] = 1/|W|by universality of H. Hence,
1
d=1
d||p||2
1≤ ||p||2
2≤1
|H|/parenleftbig1
|A|+1
|W|/parenrightbig
≤2
|H|·|W|.
(f) For each pair ( w,h) on which pin the above proof is positive, the pair ( h,h−1
A(w)) is de-
ﬁned. Moreover, this mapping is injective, and injective mappings pr eserve uniformity of random
variables on their support.
Proof of Lemma 2.7. Fixπand for random h,w,g,v let
Xπ= (h,h−1
Aπ(w)) and Yπ= (g,g−1
Bπ(v)).
By (f),Xπis deﬁned with probability 1 /2 and uniform on a set of size1
2|Hπ|·|Wπ| ≥1
4|Hπ|·|Aπ|
when deﬁned. Similar for Yπ. Hence, ( Xπ,Yπ) is deﬁned with probability 1 /4 and when deﬁned,
it is uniform on fraction 1 /16 of the elements in Hπ×Aπ×Gπ×Bπ. Thus, ( Xπ,Yπ) is15
16-close
to uniform in this set, by (c).
Let/tildewideX=Xπand/tildewideY=Yπforπrandomly selected as in the lemma. By (d), V= (/tildewideX,/tildewideY) is
15
16-close to uniform in the set/uniondisplay
πHπ×Aπ×Gπ×Bπ.
The lemma follows by applying (b) with ε= 2−5conditioned to Vbeing deﬁned.
D Breaking key-agreement means solving (Yt
c,Ne)
Proposition D.1. Letγ >6andt(n)≤nO(1). If key-agreement does not exist, then the promise
problem(Yt
c,Nc+γ)is inioBPP.
Proof.It suﬃces to assume that a single speciﬁc protocol is not a key-agr eement one. The proof
assumes that Eve can break this protocol, not just with non-neglig ible probability, but with
probability close to 1. This assumption is without loss of generality bec ause of the following.
Theorem D.2. Letα > β. If key-agreement does not exist, then each protocol with ag reement
1−1
nαis not(1−1
nβ)-secure.
A 1-bit version of this theorem was proven in [Hol05, Hol06], and the ge neral version follows from
a weak variant of the Goldreich–Levin theorem, see [BLMP23, appen dix B.2].
LetT(n) be a polynomial upper bound of t(n). Consider the following protocol.
Levin-search protocol with parameter c.Input: an integer n.
– Alice randomly samples ℓA∈[2n] anda∈ {0,1}ℓA.
Bob samples ℓB∈[2n] andb∈ {0,1}ℓB.
– They view aandbas programs and evaluate their interaction ( π,x,y) =
U(a)↔U(b). If one of the program’s runtime exceeds T(n), it always replies with 0
(the value does not matter), until it has replied T(n) times.
– Alice and Bob check whether x=yusing hashes of size ⌈(c+5)logn⌉that fail with
probability at most n−c−5. Thus, Alice sends a hash function hand value h(x),
then Bob replies whether this equals h(y) by sending 1 or 0.
– If equal, Alice outputs xand Bob y. Otherwise, they output the empty string.
11
Note that this protocol has agreement 1 −n−c−5, because if x/n⌉}ationslash=y, then both players output the
empty string, unless there is a hash collision. Also, observe that the above protocol runs in time
O(T(n)), which is polynomial by deﬁnition of T.
If key-agreement does not exist, then Holenstein’s theorem implies the existence of an ad-
versaryEwhich guesses the output with high probability. We prove that the fo llowing is an
ioBPPalgorithm.
Algorithm for solving (Yt
c,Nc+γ)on input (π,x).
– Letn=|(π,x)|.
Lethbe a random hash function with |h(x)|= (c+5)logn.
Let ˜πbe the transcriptobtained from πafter which Alice sends h,h(x) and Bobreplies
with 1.
– IfE(n,˜π) =x, output “outside N”. Otherwise, output “outside Y”.
Let us prove correctness for all ( π,x) inNc+γ, thus if C( π,x)≥C(π)+(c+γ)log|πx|. Note that
|πx| ≤n≤2|πx|. For large |π|, symmetry of information implies
C(x|π)≥C(π,x)−C(π)−(1+o(1))log|πx| ≥(c+γ−1−o(1))logn,
Thus with probability 5 /6,
C(x|˜π)≥(γ−1−5−o(1))logn,
becauseaddingarandomhashfunction htotheconditiondoesnotchangeKolmogorovcomplexity,
and adding the hash value h(x), decreases the complexity by at most |h(x)|= (c+5)logn+O(1).5
Recall that γ >6. Thus no probabilistic program can guess xwith probability 4 /5 if it only knows
˜π, (formally, one could apply the coding theorem). Hence, with proba bility at least 2 /3, the guess
ofEis wrong, i.e. E(n,˜π)/n⌉}ationslash=x, and the correct answer “outside Y” is given.
Now we prove correctness for inﬁnitely many nand inputs ( π,x)∈ Yt
cwith|(π,x)|=n. Recall
that the Levin-searchprotocolhas agreement1 −n−c−5. Thus by Theorem D.2, for every β < c+5
there exists anEve Eandinﬁnitely many nsuch that Eve guessesthe keywith probability1 −n−β.
We will later see what the right value of βshould be (it will be any constant > c+4). Fix a large
suchn.
To show correctness, we prove the contrapositive of the require ment for ( π,x)∈ Yt
cwith
|(π,x)|=n:if the answer is “outside Y” with probability >1/3, then(π,x)is outside Yt
c.
Considersets Sn,ℓofpairs forwhich Eveguesses the keywrong with probabilitymore th an 1/3:
(π,x)∈Sn,ℓ⇐⇒CIt(π,x) =ℓ,|(π,x)|=nand Pr[ E(n,˜π)/n⌉}ationslash=x|π,x]>1
3.
Note that this set is computable on input ℓandn. We need to check that for inﬁnitely many n
and for all ℓ, that the set Sn,ℓis disjoint from Yt(π,x).
For large n, we only need to consider ℓ≤2nbecause ( π,x)∈ Yt
cimplies
CIt(π,x)≤C(π)+clog|πx| ≤2|(π,x)|.
Whatistheprobabilitythatoninput n, theLevin-searchprotocolproducesaﬁxed( π,x)∈Sn,ℓ
satisfying ( π,x,x) =U(a)↔U(b)? By deﬁnition of interactive complexity, this is at least1
(2n)22−ℓ:
Alice’s and Bob’s program lengths ℓAandℓB=ℓ−ℓAare each guessed with probability 1 /(2n),
and then the programs a,bin the deﬁnition of CI are guessed with probability 2−ℓ.
5With a direct argument that does not use symmetry of informat ion, it is enough to require that ( c+γ−
o(1))logn >|h(x)|.
12
Thus each pair in Sn,ℓcontributes at least1
3·1
(2n)22−ℓto the failure probability of Eve. Since
the total failure probability is at most n−β, we conclude that
|Sn,ℓ| ≤O(n2−β·2ℓ).
SinceSn,ℓis computable, each ( π,x)∈Sn,ℓwithℓ≤2nsatisﬁes up to o(logn) terms,
C(π,x)≤log|Sn,ℓ|+2logn
≤ℓ+(2−β)logn+2logn
= CIt(π,x)+(4−β)logn,
where the last equality holds by deﬁnition of Sn,ℓ. Thus,
CIt(π,x)≥C(π)+(β−4+o(1))log|πx|.
Hence, for large n, the set Yt
cis disjoint from Sn,ℓ, provided we choose β > c+ 4, and this is
enough for Holenstein’s theorem with α=c+5.
We proved that the answers are correct for inﬁnitely many input siz es. Hence, the promise
problem is in ioBPPand the proposition is proven.6,7
6Proposition D.1 holds for all γ >3. This follows from the next improvements. Firstly, we have C(π,x)≤
CIt(π,x) + (3−β+o(1))logn, because the parameter ℓcan be extracted from the index length of Sn,ℓwith
O(loglogn) information. This means that, we may choose αandβto be slightly above 3. In the Levin-search
protocol, we use a hash of size (3+ c+ε)log|πx|, withεarbitrarily close to 0. As explained in a previous footnote,
we may choose γslightly above (3+ ε), thus also arbitrarily close to 3.
7To prove that the problem is in interval- ioBPP, we call E(n′,˜π) with increasing values of n′starting from n=
|(π,x)|up tonlogn. This aﬀects the bound on |Sn′,ℓ|by a factor log2nand the bound C( π,x)≤log|Sn′,ℓ|+logn′
by an additive term O(loglogn). Both shifts can be commpensated by arbitrarily small shif ts ofγ.
13